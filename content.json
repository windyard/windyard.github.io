{"pages":[],"posts":[{"title":"「译」使用 CSS 硬件加速提升网站性能","text":"作者： Guil Hernandez 原文链接：Increase Your Site’s Performance with Hardware-Accelerated CSS 你知道我们可以把图像相关的 CSS 特性交给 GPU(图像处理单元) 处理，以利用硬件加速在浏览器中获得更好的渲染性能吗？ 当今的大多数电脑都有可用于硬件加速的显卡。因此，我们可以利用这些 GPU 资源去处理那些比较耗性能的特性，这样我们的网站和应用在浏览器中就能获得比单纯用 CPU 处理更好的性能表现。 这篇文章里，我们会讲到桌面和手机端浏览器的 CSS 硬件加速。 桌面和手机端浏览器中的 CSS 硬件加速你有没有想过为什么有些 CSS 动画在浏览器中看起来比其他的更流畅些？ CSS animations, transforms 和 transitions 默认并不会启用 GPU 加速，而是被浏览器内部的（比较慢的）软件引擎渲染。那么到底是什么强制浏览器切换到 GPU 模式呢？许多浏览器通过一些特定的 CSS 规则启用 GPU 加速。 当前，Chrome, Firefox, Safari, IE9+ 和最新版的 Opera 都支持硬件加速；它们只有在检测到某个 DOM 元素可能会从中获益的时候才会应用硬件加速。在 CSS 中，最显眼的迹象就是这个元素使用了 3D 变换。 例如： 12345.cube &#123; -webkit-transform: translate3d(250px,250px,250px) rotate3d(250px,250px,250px,-120deg) scale3d(0.5, 0.5, 0.5);&#125; 某些时候，你可能并不需要 3D 变换但仍然想利用硬件加速。这时候有几个非常顺手的 CSS 特性可以用来触发浏览器的 GPU 加速。 尽管我们的元素并不是在 3D 空间中做动画，我们仍然可以启用 3D 渲染。闲话休提，transform: translateZ(0); 声明在桌面和手机端浏览器中都会触发 GPU 加速。看起来这是触发 GPU 加速的最有效的方式了（添加了所有浏览器前缀）： 12345678.cube &#123; -webkit-transform: translateZ(0); -moz-transform: translateZ(0); -ms-transform: translateZ(0); -o-transform: translateZ(0); transform: translateZ(0); /* Other transform properties here */&#125; 在 Chrome 和 Safari 中使用 CSS transforms 时可能会有闪烁。下面这些声明可以解决这个问题： 123456789101112.cube &#123; -webkit-backface-visibility: hidden; -moz-backface-visibility: hidden; -ms-backface-visibility: hidden; backface-visibility: hidden; -webkit-perspective: 1000; -moz-perspective: 1000; -ms-perspective: 1000; perspective: 1000; /* Other transform properties here */&#125; 另一种可以用在 Webkit 内核的桌面和手机浏览器中的方法是使用 translate3d： 1234567.cube &#123; -webkit-transform: translate3d(0, 0, 0); -moz-transform: translate3d(0, 0, 0); -ms-transform: translate3d(0, 0, 0); transform: translate3d(0, 0, 0); /* Other transform properties here */&#125; 原生的手机应用一直在利用 GPU 加速，这也就是为什么大家一直以来的印象都是原生应用要比网页应用更流畅一些。在手机上使用硬件加速来降低资源消耗是非常有必要的。 结论我们介绍的这些方法应该只用于需要动画的元素。这可以提高 2D 变换的性能，不过把这种方法用于所有元素绝不是一个好主意。 谨慎使用这些方法，只有当你遇到性能瓶颈时才需要用它们。滥用 GPU 加速将导致严重的性能问题，因为硬件加速会占用大量内存 -- 而且还会影响电池续航。 你在你的项目中用过这些方法吗？如果用过，请分享一下哪些方法最有效性能最好。","link":"/2019/03/26/css-hardware-accelerate/"},{"title":"Testing post","text":"This is a testing post.Created at February 7th, 2019, 21:26","link":"/2019/02/07/Testing-post/"},{"title":"「译」 如何在 Vue 中（安全的）使用 jQuery 插件","text":"作者：Anthony Gore 原文链接：How To (Safely) Use A jQuery Plugin With Vue.js 在一个 UI 中同时使用 Vue.js 和 jQuery 并不是一个好主意。如果可能的话要避免这种情形。 不过既然你已经看到这里了，估计你是非要同时用 Vue 和 jQuery 不可了。或许是客户坚持要使用某个 jQuery 插件而你又没时间去把它用 Vue 重写。 只要你谨慎的操作，还是可以同时使用 Vue 和 jQuery 的。这篇文章里我将演示如何在 Vue 项目中使用一个 jQuery UI 的 Datepicker 插件。 而且为了小小的炫一下技，我还要在 jQuery 插件和 Vue 之间传递数据！ 点击这里查看示例代码 JS Bin jQuery UI Datepicker 同时使用 jQuery 和 Vue 存在的问题为什么说这种用法会有潜在的风险呢？ 可以说 Vue 是一个占有欲非常强的框架，她总想完全控制你交给她的这部分 DOM 元素（传递给 el 属性的元素）。如果 jQuery 修改了 Vue 管辖下的元素，例如为某个元素添加了一个 class， Vue 无法感知到这次修改，所以下次 Vue 更新 DOM 时会直接覆盖 jQuery 所做的修改。 解决方案：把 jQuery 插件包装成 Vue 组件既然 Vue 和 jQuery 绝不会分享同一份 DOM，我们必须让 Vue 分割出一块区域交给 jQuery。 看起来把 jQuery 插件包装成 Vue 组件是个办法，因为： 我们可以利用 Vue 生命周期勾子来设置或卸载 jQuery 代码 我们可以通过组件接口使用 props 和 events 来与 Vue 应用通信 组件可以通过设置 v-once 避免被 Vue 更新 设置 jQuery UI Datepicker首先要做的当然是在你的项目中引入 jQuery UI 插件。然后你只需要把 datepicker 插件绑定到一个 input 元素上： 1Date: &lt;input id=\"datepicker\"&gt; 选中并初始化 Datepicker 1$('#datepicker').datepicker(); Datepicker 组件我们的 datepicker 组件很简单，template 只有一个 input 元素： 1234567Vue.component('date-picker', function() &#123; template: '&lt;input/&gt;'&#125;);new Vue(&#123; el: '#app'&#125;); 123&lt;div id=\"app\"&gt; Date: &lt;date-picker&gt;&lt;/date-picker&gt;&lt;/div&gt; 注意：组件只是为 jQuery 插件提供一个包装。不要试图为组件元素添加任何 data 属性或 Vue directives 或 slots。 插件实例化在这里我们将使用 this.$el 而不是 input 元素的 ID 来选择插件元素，每个 Vue 组件都可以像这样来访问到自己的根元素。我们这里的根元素就是 input。 然后我们可以把这个元素引用传递给 jQuery 选择器并调用 datepicker 方法。例：$(this.$el).datepicker()。 注意我们的代码是写在在 Vue 组件生命周期的 mounted 阶段，因为在此之前 this.$el 还是 undefined 状态。 123456Vue.component('date-picker', function() &#123; template: '&lt;input/&gt;', mounted: function() &#123; $(this.$el).datepicker(); &#125;&#125;); 卸载类似的，卸载 datepicker 插件同样也会用到生命周期勾子。注意我们必须在 beforeDestroy 阶段执行卸载，因为在这个阶段 input 元素仍然存在于 DOM 中，我们才能选中它（在 destroy 阶段它将变成 undefined）。 123456789Vue.component('date-picker', &#123; template: '&lt;input/&gt;', mounted: function() &#123; $(this.$el).datepicker(); &#125;, beforeDestroy: function() &#123; $(this.$el).datepicker('hide').datepicker('destroy'); &#125;&#125;); 通过 props 传递参数为了使我们的组件可复用，最好让它能接受自定义设置参数，例如通过设置属性 dateFormat 来制定日期格式。通过 props 可以实现这一目标： 12345678910Vue.component('date-picker', &#123; template: '&lt;input/&gt;', props: [ 'dateFormat' ], mounted: function() &#123; $(this.$el).datepicker(&#123; dateFormat: this.dateFormat &#125;); &#125;, beforeDestroy: function() &#123; ... &#125;&#125;); 123&lt;div id=\"app\"&gt; &lt;date-picker date-format=\"yy-mm-dd\"&gt;&lt;/date-picker&gt;&lt;/div&gt; 让 jQuery 接收更新比方说你不满足于只是传给 dateFormat prop 一个字符串，而是把 dateFormat 设置成 Vue 根实例上的一个属性，例： 123456var vm = new Vue(&#123; data: &#123; ... dateFormat: 'yy-mm-dd' &#125;&#125;); 123&lt;div id=\"app\"&gt; &lt;date-picker date-format=\"dateFormat\"&gt;&lt;/date-picker&gt;&lt;/div&gt; 这样一来，dateFormat 就变成了一个响应式的 data 属性。你可以随时在应用中更改它的值： 12// 更改日期显示格式vm.dateFormat = 'yy-dd-mm'; 由于 dateFormat prop 是 datepicker 组件的 mounted 钩子的依赖项，更新它的值将导致组件重新渲染。这就不妙了。因为 jQuery 已经在 input 元素上设置好了 datepicker 并且添加了自己的 class 和 事件监听。组件重新渲染将导致 input 元素被替换而且 jQuery 所做的设置也被重置了。 我们需要将组件设置为接收数据不重新渲染… v-oncev-once 指令用于缓存一个包含大量静态内容的组件。导致的结果就是这个组件渲染不会受数据更新的影响。 我们的组件正好用到这个特性，因为它有效的避免了被 Vue 重新渲染。因此我们有理由相信 jQuery 将可以在应用的生命周期中无障碍的操作这个 input 元素。 123&lt;div id=\"app\"&gt; &lt;date-picker date-format=\"yy-mm-dd\" v-once&gt;&lt;/date-picker&gt;&lt;/div&gt; 从 jQuery 向 Vue 传递数据如果我们不能在 app 中获取到 datepicker 选中的日期，那它就没啥用了。让我们来实现这个目标。 首先给 root 实例一个 date 属性： 123456new Vue(&#123; el: '#app', data: &#123; date: null &#125;&#125;); 1234&lt;div id=\"app\"&gt; &lt;date-picker date-format=\"yy-mm-dd\" v-once&gt;&lt;/date-picker&gt; &lt;p&gt;&#123;&#123; date &#125;&#125;&lt;/p&gt;&lt;/div&gt; datepicker 插件有一个 onSelect 回调函数来处理选中日期的操作。通过它我们可以在组件中使用自定义事件发出数据。 123456789mounted: function() &#123; var self = this; $(this.$el).datepicker(&#123; dateFormat: this.dateFormat, onSelect: function(date) &#123; self.$emit('update-date', date); &#125; &#125;);&#125; 在根实例上监听自定义事件并接收新数据： 1234&lt;div id=\"app\"&gt; &lt;date-picker @update-date=\"updateDate\" date-format=\"yy-mm-dd\" v-once&gt;&lt;/date-picker&gt; &lt;p&gt;&#123;&#123; date &#125;&#125;&lt;/p&gt;&lt;/div&gt; 1234567891011new Vue(&#123; el: '#app', data: &#123; date: null &#125;, methods: &#123; updateDate: function(date) &#123; this.date = date; &#125; &#125;&#125;); 感谢这个 Stack Overflow 回答 提供的灵感","link":"/2019/02/08/Use-jquery-in-vue/"},{"title":"Hello World 2","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/02/02/hello-world/"},{"title":"「译」Web Components：入门到精通 (1)","text":"作者：Pascal Schilp原文链接：Web Components: from zero to hero 一个编写原生 Web Components 的教程 什么是 Web Components？ 组件生命周期 编写我们的 to-do 应用 设置 properties 设置 attributes 将 properties 映射到 attributes 事件 浏览器支持以及 polyfill 包装 Web Components 现在有了越来越大的推动力。随着 Edge 团队宣布部署 Custom Elements 和 Shadow DOM，所有的主流浏览器都已经原生支持 Web Components。像 Github，Netflix，Youtube 和 ING 等甚至已经在生产环境中使用了 Web Components！赞！不过，很让人惊讶的是，这些成功的大公司中没有一个做过 to-do 应用！ 因此，今天我们要做一个 to-do 应用，因为世界上还没几个 to-do 应用。你可以在这里先预览一下我们要做的东西。 在开始之前，","link":"/2019/04/01/web-components-hero-1/"},{"title":"「译」5 分钟上手 Service Worker","text":"作者：Carmen Bourlon原文链接：Write Your First Service Worker in 5 Minutes 什么是 Service Worker?Service Worker 是一个让你可以在用户机器上缓存文件和其他资源的小文件。那它跟服务器端缓存 (server-side caching) 有什么区别呢？这种缓存是放在用户的机器上的，因此跟服务器端的缓存相比，它不需要再通过网络传输。这对提升你的应用的速度和可靠性是非常有好处的。由于 app 是从缓存中运行的，就不用大费周章的花时间从网络传输数据了。 为什么说它对你的应用有好处应用 Service Worker 不仅能提升应用的速度，还能为你的用户提供前所未有的可靠性。由于不再依赖实时的网络连接，应用在网络质量差的时候也能工作--说真的所有人的网络质量都不咋的。 生命周期Service Worker 生命周期基本是这样： install Activate Fetch 我们来分别讲解一下这些事件： Install在 install 事件之前，你的应用里还没有 Service Worker。浏览器会从你的代码中检测注册事件并安装 Service Worker。你的 Service Worker 包含一个名为 oninstall 的函数，它将决定哪些文件会被缓存到用户的机器上。 Activate在 Service Worker 安装就绪以后，会触发 activate 事件。此时是清理老旧无用的缓存文件的好时机。不过在这个例子中，我们并不会在 activate 事件里做任何操作。 Fetch这是我们的 Service Worker 大显身手的时候。当应用发出 fetch 请求时，我们的 Service Worker 会用一个名字也是 fetch 的函数拦截它。你的 Service Worker 会从换从中寻找类似的请求或是将这个请求发送出去。 Service Worker 生命周期中 activate 和 fetch 并不是依次执行的。Fetch 只有在有 fetch 操作时才执行拦截，因此 activate 事件和 ftech 事件之间是有间隔的。在这间隔期间，Service Worker 处于待命状态。 Service Worker 示例我们用 FayePI 来做例子。这是我写的一个帮助女性学习建设动态网站的 API，它的文档页面用了一点简单的 Service Worker。 为了安装 Service Worker，我们得先为应用添加一个注册函数。 12345// index.jsif(navigator.serviceWorker) &#123; navigator.serviceWorker.register('serviceworker.js');&#125; 上面这段代码通常放在 index.js 中以便在页面加载完成后立即执行。在你的应用代码中，这是唯一引用 Service Worker 的地方。 下面是我们的 Service Worker 文件。 123456789// serviceworker.jsself.oninstall = function() &#123; caches.open('fayeFrontEndV1').then(function(cache) &#123; cache.addAll([ / ... / ]) .catch( / ... / ); &#125;) .catch( / ... /)&#125; 这些就是安装 Sercice Worker 时执行的代码。首先我们初始化并打开 cache。我们在这里将文件缓存到用户机器上。 caches.open 返回一个包含我们打开的 cache 的引用的 promise。然后我们传给 addAll 函数一个字符串数组。这些字符串是我们要添加到缓存的文件的路径。最后我们添加几个 catch 函数来处理可能会出现的错误。 下一步是 activate: 1234// serviceworker.jsself.onactivate = function(event) &#123; console.log('sw is up and running!');&#125; 此时是进行垃圾清理的好时机，不过我们将在另一篇博文里讲解。 最后，也是最棒的部分！让我们来看看 fetch。 12345678910111213// serviceworker.jsself.onfetch = function(event) &#123; event.respondWith( caches.match(event.request) .then(function(cachedFiles) &#123; if(cachedFiles) &#123; return cachedFiles; &#125; else &#123; return fetch(event.request); &#125; &#125;) );&#125; 这个函数会在 Service Worker 检测到 fetch 请求时执行。它会在全部 cache 中试图找到匹配的请求。如果匹配成功，函数将返回 cache 中的结果。否则 Service Worker 会发送网络请求。 让我们仔细分析一下 event.respondWith 和 caches.match，这俩都是 Service Worker 专有的。 event.respondWith 让你可以打断 fetch 请求并返回你自己的响应内容。一定要注意必须用这个方法而不是简单的 return 一个返回值，只有这样你拦截的回复才能发送到正确的地方。 caches.match 让你能够搜索 CacheStorage 并找到请求的匹配项。我们向 cache 添加的内容，会被存储到一个栈中，最早添加的在最底部，最后添加的在顶部。caches.match 会返回最新的匹配项。如果没有匹配项，则返回 null。 大功告成！以上就是一个简单的 Service Worker 的全部内容！如果你觉得 Service Worker 超级酷，我推荐你了解一下它还能做什么，包括后台 fetch，在这篇博客中。 如果你想学习更多关于 Service Worker 的知识，我希望你能去 serviceworkerbook.com 并订阅我的邮件列表，并在 Twitter 关注我！你会在我的书 “Let’s Take This Offline” 出版的第一时间获悉！","link":"/2019/03/31/sw-in-5m/"},{"title":"「译」动手实现一个单文件 Web Components","text":"作者：Tomasz Jakut原文链接：Implementing single file Web Components 可能每个了解 Vue 框架的人都听说过它的“单文件组件（single file components）”。这个超简单的概念让 Web 开发人员可以只用一个文件来定一个组件。这个解决方案非常好用以至于一个在浏览器中包含这种机制的提案已经出现。 不过很不幸的是，这个提案貌似已经死掉了，从 2017 年 8 月以后就再没有任何进展。即使如此，在现有可行技术下研究这个话题并且创建一个可以在浏览器中运行的单文件组件仍然值得写一篇文章！ 单文件组件了解渐进增强这个术语的 Web 开发人员应该也听说过“分层”这个词儿。在组件中也是这样的。实际上层数还不少呢，每个组件至少有 3 层：内容/模版，样式和行为。按照传统的做法，每个组件至少会被分成 3 个文件，例如一个 Button 组件可能会是这个样子： 1234567Button/|| -- Button.html|| -- Button.css|| -- Button.js 这是按照技术来分层（内容/模版：HTML，样式：CSS，行为：JS）。这就是说--如果你没有用构建工具的话--浏览器将需要加载 3 个文件。于是有人便提出一个概念，保留分层的概念，但不是按照技术种类分成不同但文件。于是单文件组件诞生了。 一般来说，我对“按技术分层”这个做法持怀疑态度。而且，这个概念实际上经常在一些关于放弃分层的争论中被提到--根本就是完全对立的两件事。 单文件的 Button 组件看起来是这样的： 1234567891011&lt;template&gt; &lt;!-- Button.html contents go here. --&gt;&lt;/template&gt;&lt;style&gt; /* Button.css contents go here. */&lt;/style&gt;&lt;script&gt; // Button.js contents go here.&lt;/script&gt; 可以清楚的看到，单文件组件就是一个有内部样式表、script 和 &lt;template&gt; 标签的标准 HTML。得益于这种简洁的实现，你的组件不需要分成多个文件也有很明显的分层（内容/模版：&lt;template&gt;，样式：&lt;style&gt;，行为：&lt;script&gt; ）。 不过仍然又一个最重要的问题要解决：如何使用它呢？ 基础概念我们先来编写一个叫做 loadComponent() 的 全局函数来加载我们的组件。 12345window.loadComponent = ( function() &#123; function loadComponent( URL ) &#123;&#125; return loadComponent;&#125;() ); 我用到了这些组件模式。你可以定义所有需要的辅助函数，只把 loadComponent 暴露给外部作用域。目前这个函数没有任何功能。 然而我们也没什么东西需要加载，所以这也不是什么问题。在这篇文章里我们假设你要创建一个 &lt;hello-world&gt; 组件用于显示以下文字： Hello, world! My name is &lt;指定的名称&gt;. 而且当你点击了这个组件，它会弹出一个消息： Don’t touch me! 把组件代码保存为 HelloWorld.wc（.wc 代表 Web Component）。现阶段它是这样的： 12345678910111213141516171819&lt;template&gt; &lt;div class=\"hello\"&gt; &lt;p&gt;Hello, world! My name is &lt;slot&gt;&lt;/slot&gt;.&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; div &#123; background: red; border-radius: 30px; padding: 20px; font-size: 20px; text-align: center; width: 300px; margin: 0 auto; &#125;&lt;/style&gt;&lt;script&gt;&lt;/script&gt; 现在你还没有为它添加任何功能。只是定义了它的模版和样式。使用没有任何选择器的 div 以及 &lt;slot&gt; 元素的出现意味着这个组件将使用 Shadow DOM。确实如此：所有的样式和模版默认都会被隐藏在暗处。 组件在网站上的使用方式应该尽可能的简单： 123456&lt;hello-world&gt;Comandeer&lt;/hello-world&gt;&lt;script src=\"loader.js\"&gt;&lt;/script&gt;&lt;script&gt; loadComponent( 'HelloWorld.wc' );&lt;/script&gt; 组件的用法跟标准的 Custom Element 一样。唯一的区别是在使用 loadComponent() 方法之前需要先加载一个 js（这个方法位于 loader.js 文件中）。这个方法负责所有的繁重工作，像获取组件和在 customElements.define() 中注册组件。 以上就是所有的基础概念，接下来要开始动真格的了！ 基础 loader如果你想从外部文件中加载数据，你必须使用神圣的 Ajax。然而如今已经是 2018 年了，现在你可以以 Fetch API 的形式使用 Ajax： 123function loadComponent( URL ) &#123; return fetch( URL );&#125; 漂亮！不过现在你只是获取了文件，没有对它做任何操作。获取它的内容的最好方式就是把它转成文字： 12345function loadComponent( URL ) &#123; return fetch( URL ).then( ( response ) =&gt; &#123; return response.text(); &#125; );&#125; 由于现在 loadComponent() 返回的 fetch() 函数的结果是一个 Promise。你可以据此检查内容是否真正加载并检查它是不是被转成了文字： 123loadComponent( 'HelloWorld.wc' ).then( ( component ) =&gt; &#123; console.log( component );&#125; ); Chrome console 显示 HelloWorld.wc 已经加载完成并转成了纯文本 运行成功！ 解析返回值不过，只是纯文本并不能满足我们的需求。你用 HTML 写这个组件不是为了做那些不允许做的事情。毕竟你是在浏览器里--一个创建 DOM 的环境。利用它的力量！ 浏览器中又一个很棒的 DOMPaser 类让你可以创建 DOM 解析器。我们把它实例化用来把组件转换成 DOM： 1234567return fetch( URL ).then( ( response ) =&gt; &#123; return response.text();&#125; ).then( ( html ) =&gt; &#123; const parser = new DOMParser(); // 1 return parser.parseFromString( html, 'text/html' ); // 2&#125; ); 首先创建一个解析器实例(1)，然后解析组件的文本内容(2)。值得注意你使用的是 HTML 模式（&#39;text/html&#39;）。如果希望代码更好的遵循 JSX 规范或原生 Vue 组件，你可以使用 XML 模式（&#39;text/xml&#39;）。不过这样一来你就要更改组件的结构了（例如：增加一个包含所有内容的主元素）。 现在如果你再查看 loadComponent() 的返回值，你将看到一个完整的 DOM 树。 Chrome console 显示 HelloWorld.wc 的内容已经被转成了 DOM 我说的“完整的”真的是非常完整。你得到了一个带有 &lt;head&gt; 和 &lt;body&gt; 元素的完整的 HTML 文档。你可以看到，组件的内容完全在 &lt;head&gt; 元素中。这是 HTML 解析器的工作方式导致的。建立 DOM 树的原理在 HTML LS 规范中有详细的描述。太长了就不详细说了，你可以简单的认为解析器会把所有元素都放在 &lt;head&gt; 元素中，直到它遇到了只能放在 &lt;body&gt; 中的元素。你用到的所有元素（&lt;template&gt;，&lt;style&gt;，&lt;script&gt;）都允许放在 &lt;head&gt; 中。假如你在组件的开头添加了一个空的 &lt;p&gt; 标签，那么全部内容都会被渲染在 &lt;body&gt; 中。 坦率的说，这个组件是被当作有缺陷的 HTML 文档来处理的，因为它没有以 DOCTYPE 声明开头。因此它是在一个被称为 quirks mode 的模式下渲染的。好在这对你没什么影响，因为你只是用 DOM 解析器剪切出所需的组件内容。 有了 DOM 树，你能获取你所需的那部分元素： 12345678910111213141516return fetch( URL ).then( ( response ) =&gt; &#123; return response.text();&#125; ).then( ( html ) =&gt; &#123; const parser = new DOMParser(); const document = parser.parseFromString( html, 'text/html' ); const head = document.head; const template = head.querySelector( 'template' ); const style = head.querySelector( 'style' ); const script = head.querySelector( 'script' ); return &#123; template, style, script &#125;;&#125; ); 把所有的获取和解析代码移到第一个辅助函数 fetchAndParse() 中： 1234567891011121314151617181920212223242526window.loadComponent = ( function() &#123; function fetchAndParse( URL ) &#123; return fetch( URL ).then( ( response ) =&gt; &#123; return response.text(); &#125; ).then( ( html ) =&gt; &#123; const parser = new DOMParser(); const document = parser.parseFromString( html, 'text/html' ); const head = document.head; const template = head.querySelector( 'template' ); const style = head.querySelector( 'style' ); const script = head.querySelector( 'script' ); return &#123; template, style, script &#125;; &#125; ); &#125; function loadComponent( URL ) &#123; return fetchAndParse( URL ); &#125; return loadComponent;&#125;() ); Fetch API 并不是从外部文件中获取 DOM 树的唯一方法。XMLHttpRequest 有一个专门的文件模式 让你可以省掉整个的解析步骤。但是它有一个缺点：XMLHttpRequest 没有 Promise 型的 API，这需要你自行实现。 注册组件既然已经拿到所有需要的部件了，现在来编写用于注册自定义组件的 registerComponent() 函数： 123456789101112131415window.loadComponent = ( function() &#123; function fetchAndParse( URL ) &#123; […] &#125; function registerComponent() &#123; &#125; function loadComponent( URL ) &#123; return fetchAndParse( URL ).then( registerComponent ); &#125; return loadComponent;&#125;() ); 提醒一下：自定义元素必须是继承自 HTMLElement 的类。另外所有的组件都会用 Shadow DOM 来承载样式和模版内容。这也就是说所有的组件将使用相同的 class。创建： 1234567891011121314function registerComponent( &#123; template, style, script &#125; ) &#123; class UnityComponent extends HTMLElement &#123; connectedCallback() &#123; this._upcast(); &#125; _upcast() &#123; const shadow = this.attachShadow( &#123; mode: 'open' &#125; ); shadow.appendChild( style.cloneNode( true ) ); shadow.appendChild( document.importNode( template.content, true ) ); &#125; &#125;&#125; 你可以把它定义在 registerComponent() 内部，因为这个 class 会用到传给这个函数的一些数据。这个 class 会用一个跟这篇关于声明式 DOM 的文章（波兰语） 所介绍的稍微有所不同的机制来附加 Shadow DOM。 与注册组件相关的只剩下一件事--给他命名并添加到页面上的组件中。 1234567function registerComponent( &#123; template, style, script &#125; ) &#123; class UnityComponent extends HTMLElement &#123; […] &#125; return customElements.define( 'hello-world', UnityComponent );&#125; 现在测试这个组件，它看起来是这个样子的： Chrome 中显示的组件：红色圆角方块，内部有 “Hello, world! My name is Comandeer”字样 获取脚本内容简单的部分已经做完了。现在该做点高难度的：添加行为层并且……将组件名称动态化。上一步里你把组件名称硬编码在代码里了，不过，它应该是从组件上获取。同样的做法也会被用在为自定义组件绑定事件监听器上。使用基于 Vue 的约定： 12345678910111213141516&lt;template&gt; […]&lt;/template&gt;&lt;style&gt; […]&lt;/style&gt;&lt;script&gt; export default &#123; // 1 name: 'hello-world', // 2 onClick() &#123; // 3 alert( `Don't touch me!` ); &#125; &#125;&lt;/script&gt; 假定组件中的 &lt;script&gt; 是一个模块，它可以导出内容(1)，导出的是一个包含组件名称(2)和以 on... 开头的事件监听器方法(3)的对象。 看起来不错，也没有任何泄漏（因为在全局作用域中不存在模块）。然而还有一个问题：如何处理内部模块的导出并没有一个标准（那些直接写在 HTML 文档中的代码也是）。导入声明会假设它得到的是一个模块标识符。多数情况下是一个代码文件的 URL。内部模没有这种标识符。 别着急放弃，你可以用一个超级脏的 hack。至少有两种方法能强制浏览器将文本当作文件来处理：Data URI 和 Object URI。 Stack Overflow 建议使用 Service Worker。不过在我们这个案例中有点大材小用了。 Data URI 和 Object URIData URI 是一个古老而原始的方案。它是去用除文件内容中无用的空格并且如果指定会把所有内容转成 Base64 编码的方式将文件转成 URL。假设你有一个非常简单的 JavaScript 文件： 1export default true; 它的 Data URI 形式是这样的： 1data:application/javascript;base64,ZXhwb3J0IGRlZmF1bHQgdHJ1ZTs= 你可以像引用一个文件一样引用这个 URL： 123import test from 'data:application/javascript;base64,ZXhwb3J0IGRlZmF1bHQgdHJ1ZTs=';console.log( test ); 然而我们一眼就能看出 Data URI 方式的缺陷：JavaScript 文件越来越大，URL 也就变得越来越长。以简明的方式将二进制数据转成 Data URI 也很困难。因此人们创造了 Object URI。它是几个标准的产物，包括 File API 和包括 &lt;video&gt; 和 &lt;audio&gt; 的 HTML 5.x。Object URI 的目标很简单：从二进制数据生成虚拟文件，返回一个只在当前页面有效的唯一 URL。简单的说：在内存中创建一个具有唯一名称的文件。这样你就利用了 Data URI 的所有优势（用简单的方式创建新“文件”）又避免了它的缺陷（你不用在代码中包含可能多达 100MB 的文字了）。 流媒体（例如：&lt;video&gt; 和 &lt;audio&gt;）或者使用拖拽方式通过 input[type=file] 上传文件经常会创建 Object URI。不过你也可以用 File 和 Blob 类手动创建类似的文件。在这个案例中我们要把模块的内容储存在 Blog 类中并把它转换成 Object URI： 1234const myJSFile = new Blob( [ 'export default true;' ], &#123; type: 'application/javascript' &#125; );const myJSURL = URL.createObjectURL( myJSFile );console.log( myJSURL ); // blob:https://blog.comandeer.pl/8e8fbd73-5505-470d-a797-dfb06ca71333 动态导入不过还有一个问题：import 声明无法接收一个作为模块标识符的变量。这意味着你能把这个模块转换成“文件”却无法导入。到头来还是行不通？ 不是的。很早以前人们就注意到了这个问题并提出了动态导入提案。写这篇文章的时候（2018 年 8 月）已经进行到标准化的第三阶段了，在浏览器和其他 JavaScript 环境中已经开始部署。使用变量作为模块标识符以及动态导入已经没问题了： 123456const myJSFile = new Blob( [ 'export default true;' ], &#123; type: 'application/javascript' &#125; );const myJSURL = URL.createObjectURL( myJSFile );import( myJSURL ).then( ( module ) =&gt; &#123; console.log( module.default ); // true&#125; ); 可以看到，import() 的用法跟函数一样并返回一个 Promise，它是一个代表模块的对象。包含了所有声明过的导出项目，默认的导出项以 default 属性标识。 部署既然你已经知道你要做什么，那么就动手吧。添加下一个辅助函数 getSettings()。它会在 registerComponents() 之前被调用来从脚本中获取必须的信息： 12345678910111213function getSettings( &#123; template, style, script &#125; ) &#123; return &#123; template, style, script &#125;;&#125;[…]function loadComponent( URL ) &#123; return fetchAndParse( URL ).then( getSettings ).then( registerComponent );&#125; 目前这个函数只是返回了所有传给它的参数。我们要把上面提到的整个的逻辑添加进去。首先，把脚本转成 Object URI： 12const jsFile = new Blob( [ script.textContent ], &#123; type: 'application/javascript' &#125; );const jsURL = URL.createObjectURL( jsFile ); 然后，通过 import 加载它并返回 template，styles 和从 &lt;script&gt; 中提取的组件名称。 1234567return import( jsURL ).then( ( module ) =&gt; &#123; return &#123; name: module.default.name, template, style &#125;&#125; ); 借助于此，registerComponent() 接收的 3 个参数里 &lt;script&gt; 变成了组件的名称。修改代码： 1234567function registerComponent( &#123; template, style, name &#125; ) &#123; class UnityComponent extends HTMLElement &#123; […] &#125; return customElements.define( name, UnityComponent );&#125; ＼( ｀∀´)／ Voilà! 行为层组件还有一部分没完成：行为，即处理事件。目前你只能从 getSettings() 函数获取组件的名字，你还需要获取事件监听器。Object.entries() 可以用来实现这个目的。我们回到 getSettings() 给它添加适当代码： 1234567891011121314151617181920212223242526function getSettings( &#123; template, style, script &#125; ) &#123; […] function getListeners( settings ) &#123; // 1 const listeners = &#123;&#125;; Object.entries( settings ).forEach( ( [ setting, value ] ) =&gt; &#123; // 3 if ( setting.startsWith( 'on' ) ) &#123; // 4 listeners[ setting[ 2 ].toLowerCase() + setting.substr( 3 ) ] = value; // 5 &#125; &#125; ); return listeners; &#125; return import( jsURL ).then( ( module ) =&gt; &#123; const listeners = getListeners( module.default ); // 2 return &#123; name: module.default.name, listeners, // 6 template, style &#125; &#125; );&#125; 函数变得复杂了。出现了新的辅助函数 getListeners() (1)。模块的 export 被传递给它(2)。然后使用 Object.entries() 遍历了这个 export 的所有属性(3)。如果当前属性名以 on... 开头(4)，就把这个属性的值赋给 listeners 对象，并把 setting[2].toLowerCase() + setting.substr(3) 作为它的属性名(5)。这个属性名是通过去掉 on 前缀后把首字母转换成小写（这样 onClick 会被转换成 click）得到的。然后把 listeners 对象传出去(6)。 可以用 [].reduce() 代替 [].forEach() 来处理 listeners 变量： 123456789function getListeners( settings ) &#123; return Object.entries( settings ).reduce( ( listeners, [ setting, value ] ) =&gt; &#123; if ( setting.startsWith( 'on' ) ) &#123; listeners[ setting[ 2 ].toLowerCase() + setting.substr( 3 ) ] = value; &#125; return listeners; &#125;, &#123;&#125; );&#125; 现在你可以在组件的 class 中绑定这些监听器了： 123456789101112131415161718function registerComponent( &#123; template, style, name, listeners &#125; ) &#123; // 1 class UnityComponent extends HTMLElement &#123; connectedCallback() &#123; this._upcast(); this._attachListeners(); // 2 &#125; […] _attachListeners() &#123; Object.entries( listeners ).forEach( ( [ event, listener ] ) =&gt; &#123; // 3 this.addEventListener( event, listener, false ); // 4 &#125; ); &#125; &#125; return customElements.define( name, UnityComponent );&#125; 重构过程中我们增加了一个新的参数 listeners (1)，以及 class 中的一个新的方法 _attachListeners (2)。我们又一次用到了 Object.entries()--这次是用来遍历 listeners (3) 并把它们绑定到这个组件元素上 (4)。 做完这些以后我们的组件应该会响应点击事件了： 点击了这个组件以后 Chrome 弹框显示：“Don’t touch me!” 以上就是如何实现一个单文件 Web Components 🎉! 浏览器兼容性以及其他你可以看出，即使是为了支持一个最简单形式的单文件组件，也需要做非常多的工作。我们所展现的这个系统中的许多部分都是用脏 hack 实现的（用 Object URI 来加载 ES 模块？--什么鬼！）而且如果没有浏览器的原生支持，这项技术也没什么意义。更重要的是，在我写这篇文章的时候（2018 年 8 月）Firefox 并不支持 Custom Elements 和 dynamic import。坦白说这东西现在只在 Chrome 里好使。因此--目前来说--它只是为了满足一下好奇心，没什么实际用处。 不过实现一个这样的东西还是很好玩的。它是一个涉及了许多浏览器开发和现代 web 标准相关内容的与众不同的小玩意儿。我希望至少能有一个人看完了这篇文章！ 当然了整个作品可以在网上预览。","link":"/2019/03/27/single-file-web-components/"}],"tags":[{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"Hardware accelerate","slug":"Hardware-accelerate","link":"/tags/Hardware-accelerate/"},{"name":"硬件加速","slug":"硬件加速","link":"/tags/硬件加速/"},{"name":"VueJS","slug":"VueJS","link":"/tags/VueJS/"},{"name":"jQuery","slug":"jQuery","link":"/tags/jQuery/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"Web Components","slug":"Web-Components","link":"/tags/Web-Components/"},{"name":"Service Worker","slug":"Service-Worker","link":"/tags/Service-Worker/"},{"name":"App","slug":"App","link":"/tags/App/"},{"name":"JS 应用","slug":"JS-应用","link":"/tags/JS-应用/"},{"name":"应用","slug":"应用","link":"/tags/应用/"},{"name":"Javascript","slug":"Javascript","link":"/tags/Javascript/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"}],"categories":[]}