{"pages":[{"title":"","text":"","link":"/about/index.html"}],"posts":[{"title":"「译」 如何在 Vue 中（安全的）使用 jQuery 插件","text":"作者：Anthony Gore 原文链接：How To (Safely) Use A jQuery Plugin With Vue.js 在一个 UI 中同时使用 Vue.js 和 jQuery 并不是一个好主意。如果可能的话要避免这种情形。 不过既然你已经看到这里了，估计你是非要同时用 Vue 和 jQuery 不可了。或许是客户坚持要使用某个 jQuery 插件而你又没时间去把它用 Vue 重写。 只要你谨慎的操作，还是可以同时使用 Vue 和 jQuery 的。这篇文章里我将演示如何在 Vue 项目中使用一个 jQuery UI 的 Datepicker 插件。 而且为了小小的炫一下技，我还要在 jQuery 插件和 Vue 之间传递数据！ 点击这里查看示例代码 JS Bin jQuery UI Datepicker 同时使用 jQuery 和 Vue 存在的问题为什么说这种用法会有潜在的风险呢？ 可以说 Vue 是一个占有欲非常强的框架，她总想完全控制你交给她的这部分 DOM 元素（传递给 el 属性的元素）。如果 jQuery 修改了 Vue 管辖下的元素，例如为某个元素添加了一个 class， Vue 无法感知到这次修改，所以下次 Vue 更新 DOM 时会直接覆盖 jQuery 所做的修改。 解决方案：把 jQuery 插件包装成 Vue 组件既然 Vue 和 jQuery 绝不会分享同一份 DOM，我们必须让 Vue 分割出一块区域交给 jQuery。 看起来把 jQuery 插件包装成 Vue 组件是个办法，因为： 我们可以利用 Vue 生命周期勾子来设置或卸载 jQuery 代码 我们可以通过组件接口使用 props 和 events 来与 Vue 应用通信 组件可以通过设置 v-once 避免被 Vue 更新 设置 jQuery UI Datepicker首先要做的当然是在你的项目中引入 jQuery UI 插件。然后你只需要把 datepicker 插件绑定到一个 input 元素上： 1Date: 选中并初始化 Datepicker 1$('#datepicker').datepicker(); Datepicker 组件我们的 datepicker 组件很简单，template 只有一个 input 元素： 1234567Vue.component('date-picker', function() { template: ''});new Vue({ el: '#app'}); 123 Date: 注意：组件只是为 jQuery 插件提供一个包装。不要试图为组件元素添加任何 data 属性或 Vue directives 或 slots。 插件实例化在这里我们将使用 this.$el 而不是 input 元素的 ID 来选择插件元素，每个 Vue 组件都可以像这样来访问到自己的根元素。我们这里的根元素就是 input。 然后我们可以把这个元素引用传递给 jQuery 选择器并调用 datepicker 方法。例：$(this.$el).datepicker()。 注意我们的代码是写在在 Vue 组件生命周期的 mounted 阶段，因为在此之前 this.$el 还是 undefined 状态。 123456Vue.component('date-picker', function() { template: '', mounted: function() { $(this.$el).datepicker(); }}); 卸载类似的，卸载 datepicker 插件同样也会用到生命周期勾子。注意我们必须在 beforeDestroy 阶段执行卸载，因为在这个阶段 input 元素仍然存在于 DOM 中，我们才能选中它（在 destroy 阶段它将变成 undefined）。 123456789Vue.component('date-picker', { template: '', mounted: function() { $(this.$el).datepicker(); }, beforeDestroy: function() { $(this.$el).datepicker('hide').datepicker('destroy'); }}); 通过 props 传递参数为了使我们的组件可复用，最好让它能接受自定义设置参数，例如通过设置属性 dateFormat 来制定日期格式。通过 props 可以实现这一目标： 12345678910Vue.component('date-picker', { template: '', props: [ 'dateFormat' ], mounted: function() { $(this.$el).datepicker({ dateFormat: this.dateFormat }); }, beforeDestroy: function() { ... }}); 123 让 jQuery 接收更新比方说你不满足于只是传给 dateFormat prop 一个字符串，而是把 dateFormat 设置成 Vue 根实例上的一个属性，例： 123456var vm = new Vue({ data: { ... dateFormat: 'yy-mm-dd' }}); 123 这样一来，dateFormat 就变成了一个响应式的 data 属性。你可以随时在应用中更改它的值： 12// 更改日期显示格式vm.dateFormat = 'yy-dd-mm'; 由于 dateFormat prop 是 datepicker 组件的 mounted 钩子的依赖项，更新它的值将导致组件重新渲染。这就不妙了。因为 jQuery 已经在 input 元素上设置好了 datepicker 并且添加了自己的 class 和 事件监听。组件重新渲染将导致 input 元素被替换而且 jQuery 所做的设置也被重置了。 我们需要将组件设置为接收数据不重新渲染… v-oncev-once 指令用于缓存一个包含大量静态内容的组件。导致的结果就是这个组件渲染不会受数据更新的影响。 我们的组件正好用到这个特性，因为它有效的避免了被 Vue 重新渲染。因此我们有理由相信 jQuery 将可以在应用的生命周期中无障碍的操作这个 input 元素。 123 从 jQuery 向 Vue 传递数据如果我们不能在 app 中获取到 datepicker 选中的日期，那它就没啥用了。让我们来实现这个目标。 首先给 root 实例一个 date 属性： 123456new Vue({ el: '#app', data: { date: null }}); 1234 {{ date }} datepicker 插件有一个 onSelect 回调函数来处理选中日期的操作。通过它我们可以在组件中使用自定义事件发出数据。 123456789mounted: function() { var self = this; $(this.$el).datepicker({ dateFormat: this.dateFormat, onSelect: function(date) { self.$emit('update-date', date); } });} 在根实例上监听自定义事件并接收新数据： 1234 {{ date }} 1234567891011new Vue({ el: '#app', data: { date: null }, methods: { updateDate: function(date) { this.date = date; } }}); 感谢这个 Stack Overflow 回答 提供的灵感","link":"/2019/02/08/Use-jquery-in-vue/"},{"title":"「译」7 个用 Async/Await 取代 Promise 的理由（教程）","text":"作者：Mostafa Gaafar 原文链接：7 Reasons Why JavaScript Async/Await Is Better Than Plain Promises (Tutorial) Async/Await 由 NodeJS 7.6 版本引入，现在已经被所有现代浏览器所支持。我认为这是 JS 自 2017 年以来最棒的更新。如果你不信，这里有一堆带着示例的理由告诉你为什么你应该尽快接受它并且永不再回头。 Async/Await 概述对那些从未听说过这个话题的\b，这里有一个简介： Asyne/Await 是一种新的异步代码写法。以前用于写异步代码的是 callback 和 Promise。 Async/Await 实际上是基于 Promise 的语法糖。无法用在只有 callback 或 node callba 的情形中。 Async/Await 跟 Promise 一样是非阻塞的。 Async/Await 使得异步代码的写法和行为都有点类似同步代码。这正是它强大的地方。 语法假设有一个 getJSON 函数，它返回一个 Promise，然后这个 Promise 会解析出几个 JSON 对象。我们要调用这个函数，打印出 JSON 并返回一个 “done” 字符串。 这是用 Promise 方式实现： 12345678const makeRequest = () => getJSON() .then(data => { console.log(data) return \"done\" })makeRequest() 然后这是用 Async/Await 方式实现： 123456const makeRequest = async () => { console.log(await getJSON()) return \"done\"}makeRequest() 这里有几点不同之处： 函数前面有 async 关键字。await 关键字只能用在由 async 关键字定义的函数里。async 函数会隐式的返回一个 Promise，这个 Promise 的解析值是函数的返回值（在这个例子中是 \"done\" 字符串）。 上面提到的这点也暗示了我们不能将 await 用在我们代码的最外层，因为它必须被放置在 async 函数内部。 1234567// this will not work in top level// await makeRequest()// this will workmakeRequest().then((result) => { // do something}) await getJSON() 意思是 console.log 将会等待 getJSON 的 Promise 解析出结果，然后才把结果打印出来。 好在那里呢？ 简洁干净看我们节省了多少代码！即使在我们随手编的示例代码中，也能明显的看到省了不少代码。我们无需再写 .then 然后用一个匿名函数来处理返回值，也不需要定义一个 data 变量来表示返回值。另外我们还避免了代码嵌套。接下来的例子中我们将更明显的看到这一个个的优点将累积成巨大的优势。 错误处理Async/Await 让我们可以用惯用的 try/catch 结构来处理同步和异步错误。下面的例子中有一个 Promise，try/catch 无法捕获 JSON.parse 产生的错误，因为这个错误是在 Promise 内部产生的。我们需要在 Promise 上调用 .catch 方法并复制一份错误处理的代码到这里，在你的生产代码中，这样写应该会比 console.log 更稳妥一些。 12345678910111213141516const makeRequest = () => { try { getJSON() .then(result => { // 这个解析将会失败 const data = JSON.parse(result) console.log(data) }) // 取消此处注释以处理异步错误 // .catch((err) => { // console.log(err) // }) } catch (err) { console.log(err) }} 现在我们用 async/await 来写同样的代码。现在 catch 代码将能够处理解析错误。 123456789const makeRequest = async () => { try { // this parse may fail const data = JSON.parse(await getJSON()) console.log(data) } catch (err) { console.log(err) }} 条件语句假设下面的代码将会获取一些数据，并根据数据内容决定是要返回数据还是基于获取的内容进行进一步操作。 123456789101112131415const makeRequest = () => { return getJSON() .then(data => { if (data.needsAnotherRequest) { return makeAnotherRequest(data) .then(moreData => { console.log(moreData) return moreData }) } else { console.log(data) return data } })} 光是看这些代码就让人头疼。而且这么多的嵌套（6 层）、括号、以及为了把最终结果传递到主 Promise 的 return 语句很容易让人晕头转向。 当我们用 async/await 重写这个例子后，代码则变得非常易读。 1234567891011const makeRequest = async () => { const data = await getJSON() if (data.needsAnotherRequest) { const moreData = await makeAnotherRequest(data); console.log(moreData) return moreData } else { console.log(data) return data }} 中间值你可能会遇到这样的情形：调用 Promise1 然后用它的返回值调用 Promise2，然后再用它们两个的返回值来调用 Promise3。你的代码可能会像这样： 1234567891011const makeRequest = () => { return promise1() .then(value1 => { // do something return promise2(value1) .then(value2 => { // do something return promise3(value1, value2) }) })} 如果 promise3 不需要 value1 那么就可以将 Promise 嵌套弄的扁平一些。要是你无法接受这种做法，那么你可以把 value1 和 value2 都包在一个 Promise.all 中来避免深层的嵌套，像这样： 1234567891011const makeRequest = () => { return promise1() .then(value1 => { // do something return Promise.all([value1, promise2(value1)]) }) .then(([value1, value2]) => { // do something return promise3(value1, value2) })} 这种方案为了可读性牺牲了部分语义。将 value1 和 value2 放在同一个数组中没有任何意义，只是为了避免 Promise 的嵌套。 用 async/await 实现同样的逻辑异乎寻常的简单和直观。它让你质疑自己那些花在拼命优化 Promise 代码上的时间本可以做多少美妙的事情。 12345const makeRequest = async () => { const value1 = await promise1() const value2 = await promise2(value1) return promise3(value1, value2)} 错误堆栈设想有一段链式调用多个 Promise 的代码，在链的某一部分，抛出了一个错误。 1234567891011121314151617const makeRequest = () => { return callAPromise() .then(() => callAPromise()) .then(() => callAPromise()) .then(() => callAPromise()) .then(() => callAPromise()) .then(() => { throw new Error(\"oops\"); })}makeRequest() .catch(err => { console.log(err); // output // Error: oops at callAPromise.then.then.then.then.then (index.js:8:13) }) Promise 链返回的错误的堆栈没有给出错误产生位置的信息。更糟糕的是，它还有误导性；它包含的唯一一个函数名 callAPromise 在这里完全是无辜的（不过文件名和行号还是有用的）。 相反，async/await 给出的错误堆栈指出了真正包含错误的函数。 123456789101112131415const makeRequest = async () => { await callAPromise() await callAPromise() await callAPromise() await callAPromise() await callAPromise() throw new Error(\"oops\");}makeRequest() .catch(err => { console.log(err); // output // Error: oops at makeRequest (index.js:7:9) }) 当你开着编辑器在本地写代码时，这可能影响不大，不过当你试图从生产服务器分析错误日志时用处就大了。这时候，知道错误产生在 makeRequest 要好过知道错误发生在一个 then 后的 then 后的 then … 调试用 async/await 的一个杀手级优势是调试起来更简单。由于以下两个原因，调试 Promise 一直是个痛点： 返回值是表达式（没有函数体）的箭头函数无法设置断点。 如果你在某个 .then 代码块内部设置断点然后使用步进调试，调试器不会移到下一个 .then 中，因为它只能”步进“同步代码。 使用 async/await 时不需要太依赖箭头函数，并且你可以像调试同步代码那样步进 await 调用。 你可以 await 一切最后的要点，await 在同步和异步代码中都可以使用。例如你可以写 await 5， 相当于 `Promise.resolve(5)。乍看起来可能没啥用，但是在你写工具或库函数时，用于处理不确定输入是同步还是异步的情况时是非常有用的。 假如你想记录你应用里某个 API 执行的时间，并希望这个记录函数是通用的。用 Promise 实现如下： 1234567const recordTime = (makeRequest) => { const timeStart = Date.now(); makeRequest().then(() => { // throws error for sync functions (.then is not a function) const timeEnd = Date.now(); console.log('time take:', timeEnd - timeStart); })} 我们知道这里所有的 API 调用都返回 Promise，但是如果你用这个函数去记录一个同步函数的执行时间呢？它将会抛出一个错误因为同步函数不返回 Promise。一个很有效的解决方法是把函数包裹在 Promise.resolve() 中。 如果使用 async/await，你就无需担心上述情况，因为 await 让你安全的处理任何值，无论是否是 Promise。 123456const recordTime = async (makeRequest) => { const timeStart = Date.now(); await makeRequest(); // works for any sync or async function const timeEnd = Date.now(); console.log('time take:', timeEnd - timeStart);} 结论Async/Await 是近年来 JavaScript 添加的革命性的特性之一。它让你认识到 Promise 语法是多么混乱，并提供了一个更直观的替代方式。 疑虑在使用 async/await 时你可能会有些疑虑，因为它让异步代码的特征不那么明显了：以前我们一看到 .then 回调就知道是异步代码，现在可能需要花几周时间来适应新的写法，不过 C# 中已经引入这个特性好几年了，了解它的人都知道这短暂的不适应是值得的。 Follow me on twitter @imgaafar This article was originally published on Hackernoon","link":"/2019/09/09/6-reasons-async-await/"},{"title":"Hello World 2","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/02/02/hello-world/"},{"title":"Testing post","text":"This is a testing post.Created at February 7th, 2019, 21:26","link":"/2019/02/07/Testing-post/"},{"title":"「译」动手实现一个单文件 Web Components","text":"作者：Tomasz Jakut原文链接：Implementing single file Web Components 可能每个了解 Vue 框架的人都听说过它的“单文件组件（single file components）”。这个超简单的概念让 Web 开发人员可以只用一个文件来定一个组件。这个解决方案非常好用以至于一个在浏览器中包含这种机制的提案已经出现。 不过很不幸的是，这个提案貌似已经死掉了，从 2017 年 8 月以后就再没有任何进展。即使如此，在现有可行技术下研究这个话题并且创建一个可以在浏览器中运行的单文件组件仍然值得写一篇文章！ 单文件组件了解渐进增强这个术语的 Web 开发人员应该也听说过“分层”这个词儿。在组件中也是这样的。实际上层数还不少呢，每个组件至少有 3 层：内容/模版，样式和行为。按照传统的做法，每个组件至少会被分成 3 个文件，例如一个 Button 组件可能会是这个样子： 1234567Button/|| -- Button.html|| -- Button.css|| -- Button.js 这是按照技术来分层（内容/模版：HTML，样式：CSS，行为：JS）。这就是说--如果你没有用构建工具的话--浏览器将需要加载 3 个文件。于是有人便提出一个概念，保留分层的概念，但不是按照技术种类分成不同但文件。于是单文件组件诞生了。 一般来说，我对“按技术分层”这个做法持怀疑态度。而且，这个概念实际上经常在一些关于放弃分层的争论中被提到--根本就是完全对立的两件事。 单文件的 Button 组件看起来是这样的： 1234567891011 /* Button.css contents go here. */ // Button.js contents go here. 可以清楚的看到，单文件组件就是一个有内部样式表、script 和 标签的标准 HTML。得益于这种简洁的实现，你的组件不需要分成多个文件也有很明显的分层（内容/模版：，样式：，行为： ）。 不过仍然又一个最重要的问题要解决：如何使用它呢？ 基础概念我们先来编写一个叫做 loadComponent() 的 全局函数来加载我们的组件。 12345window.loadComponent = ( function() { function loadComponent( URL ) {} return loadComponent;}() ); 我用到了这些组件模式。你可以定义所有需要的辅助函数，只把 loadComponent 暴露给外部作用域。目前这个函数没有任何功能。 然而我们也没什么东西需要加载，所以这也不是什么问题。在这篇文章里我们假设你要创建一个 组件用于显示以下文字： Hello, world! My name is . 而且当你点击了这个组件，它会弹出一个消息： Don’t touch me! 把组件代码保存为 HelloWorld.wc（.wc 代表 Web Component）。现阶段它是这样的： 12345678910111213141516171819 Hello, world! My name is . div { background: red; border-radius: 30px; padding: 20px; font-size: 20px; text-align: center; width: 300px; margin: 0 auto; } 现在你还没有为它添加任何功能。只是定义了它的模版和样式。使用没有任何选择器的 div 以及 元素的出现意味着这个组件将使用 Shadow DOM。确实如此：所有的样式和模版默认都会被隐藏在暗处。 组件在网站上的使用方式应该尽可能的简单： 123456Comandeer loadComponent( 'HelloWorld.wc' ); 组件的用法跟标准的 Custom Element 一样。唯一的区别是在使用 loadComponent() 方法之前需要先加载一个 js（这个方法位于 loader.js 文件中）。这个方法负责所有的繁重工作，像获取组件和在 customElements.define() 中注册组件。 以上就是所有的基础概念，接下来要开始动真格的了！ 基础 loader如果你想从外部文件中加载数据，你必须使用神圣的 Ajax。然而如今已经是 2018 年了，现在你可以以 Fetch API 的形式使用 Ajax： 123function loadComponent( URL ) { return fetch( URL );} 漂亮！不过现在你只是获取了文件，没有对它做任何操作。获取它的内容的最好方式就是把它转成文字： 12345function loadComponent( URL ) { return fetch( URL ).then( ( response ) => { return response.text(); } );} 由于现在 loadComponent() 返回的 fetch() 函数的结果是一个 Promise。你可以据此检查内容是否真正加载并检查它是不是被转成了文字： 123loadComponent( 'HelloWorld.wc' ).then( ( component ) => { console.log( component );} ); Chrome console 显示 HelloWorld.wc 已经加载完成并转成了纯文本 运行成功！ 解析返回值不过，只是纯文本并不能满足我们的需求。你用 HTML 写这个组件不是为了做那些不允许做的事情。毕竟你是在浏览器里--一个创建 DOM 的环境。利用它的力量！ 浏览器中又一个很棒的 DOMPaser 类让你可以创建 DOM 解析器。我们把它实例化用来把组件转换成 DOM： 1234567return fetch( URL ).then( ( response ) => { return response.text();} ).then( ( html ) => { const parser = new DOMParser(); // 1 return parser.parseFromString( html, 'text/html' ); // 2} ); 首先创建一个解析器实例(1)，然后解析组件的文本内容(2)。值得注意你使用的是 HTML 模式（'text/html'）。如果希望代码更好的遵循 JSX 规范或原生 Vue 组件，你可以使用 XML 模式（'text/xml'）。不过这样一来你就要更改组件的结构了（例如：增加一个包含所有内容的主元素）。 现在如果你再查看 loadComponent() 的返回值，你将看到一个完整的 DOM 树。 Chrome console 显示 HelloWorld.wc 的内容已经被转成了 DOM 我说的“完整的”真的是非常完整。你得到了一个带有 和 元素的完整的 HTML 文档。你可以看到，组件的内容完全在 元素中。这是 HTML 解析器的工作方式导致的。建立 DOM 树的原理在 HTML LS 规范中有详细的描述。太长了就不详细说了，你可以简单的认为解析器会把所有元素都放在 元素中，直到它遇到了只能放在 中的元素。你用到的所有元素（，，）都允许放在 中。假如你在组件的开头添加了一个空的 标签，那么全部内容都会被渲染在 中。 坦率的说，这个组件是被当作有缺陷的 HTML 文档来处理的，因为它没有以 DOCTYPE 声明开头。因此它是在一个被称为 quirks mode 的模式下渲染的。好在这对你没什么影响，因为你只是用 DOM 解析器剪切出所需的组件内容。 有了 DOM 树，你能获取你所需的那部分元素： 12345678910111213141516return fetch( URL ).then( ( response ) => { return response.text();} ).then( ( html ) => { const parser = new DOMParser(); const document = parser.parseFromString( html, 'text/html' ); const head = document.head; const template = head.querySelector( 'template' ); const style = head.querySelector( 'style' ); const script = head.querySelector( 'script' ); return { template, style, script };} ); 把所有的获取和解析代码移到第一个辅助函数 fetchAndParse() 中： 1234567891011121314151617181920212223242526window.loadComponent = ( function() { function fetchAndParse( URL ) { return fetch( URL ).then( ( response ) => { return response.text(); } ).then( ( html ) => { const parser = new DOMParser(); const document = parser.parseFromString( html, 'text/html' ); const head = document.head; const template = head.querySelector( 'template' ); const style = head.querySelector( 'style' ); const script = head.querySelector( 'script' ); return { template, style, script }; } ); } function loadComponent( URL ) { return fetchAndParse( URL ); } return loadComponent;}() ); Fetch API 并不是从外部文件中获取 DOM 树的唯一方法。XMLHttpRequest 有一个专门的文件模式 让你可以省掉整个的解析步骤。但是它有一个缺点：XMLHttpRequest 没有 Promise 型的 API，这需要你自行实现。 注册组件既然已经拿到所有需要的部件了，现在来编写用于注册自定义组件的 registerComponent() 函数： 123456789101112131415window.loadComponent = ( function() { function fetchAndParse( URL ) { […] } function registerComponent() { } function loadComponent( URL ) { return fetchAndParse( URL ).then( registerComponent ); } return loadComponent;}() ); 提醒一下：自定义元素必须是继承自 HTMLElement 的类。另外所有的组件都会用 Shadow DOM 来承载样式和模版内容。这也就是说所有的组件将使用相同的 class。创建： 1234567891011121314function registerComponent( { template, style, script } ) { class UnityComponent extends HTMLElement { connectedCallback() { this._upcast(); } _upcast() { const shadow = this.attachShadow( { mode: 'open' } ); shadow.appendChild( style.cloneNode( true ) ); shadow.appendChild( document.importNode( template.content, true ) ); } }} 你可以把它定义在 registerComponent() 内部，因为这个 class 会用到传给这个函数的一些数据。这个 class 会用一个跟这篇关于声明式 DOM 的文章（波兰语） 所介绍的稍微有所不同的机制来附加 Shadow DOM。 与注册组件相关的只剩下一件事--给他命名并添加到页面上的组件中。 1234567function registerComponent( { template, style, script } ) { class UnityComponent extends HTMLElement { […] } return customElements.define( 'hello-world', UnityComponent );} 现在测试这个组件，它看起来是这个样子的： Chrome 中显示的组件：红色圆角方块，内部有 “Hello, world! My name is Comandeer”字样 获取脚本内容简单的部分已经做完了。现在该做点高难度的：添加行为层并且……将组件名称动态化。上一步里你把组件名称硬编码在代码里了，不过，它应该是从组件上获取。同样的做法也会被用在为自定义组件绑定事件监听器上。使用基于 Vue 的约定： 12345678910111213141516 […] […] export default { // 1 name: 'hello-world', // 2 onClick() { // 3 alert( `Don't touch me!` ); } } 假定组件中的 是一个模块，它可以导出内容(1)，导出的是一个包含组件名称(2)和以 on... 开头的事件监听器方法(3)的对象。 看起来不错，也没有任何泄漏（因为在全局作用域中不存在模块）。然而还有一个问题：如何处理内部模块的导出并没有一个标准（那些直接写在 HTML 文档中的代码也是）。导入声明会假设它得到的是一个模块标识符。多数情况下是一个代码文件的 URL。内部模没有这种标识符。 别着急放弃，你可以用一个超级脏的 hack。至少有两种方法能强制浏览器将文本当作文件来处理：Data URI 和 Object URI。 Stack Overflow 建议使用 Service Worker。不过在我们这个案例中有点大材小用了。 Data URI 和 Object URIData URI 是一个古老而原始的方案。它是去用除文件内容中无用的空格并且如果指定会把所有内容转成 Base64 编码的方式将文件转成 URL。假设你有一个非常简单的 JavaScript 文件： 1export default true; 它的 Data URI 形式是这样的： 1data:application/javascript;base64,ZXhwb3J0IGRlZmF1bHQgdHJ1ZTs= 你可以像引用一个文件一样引用这个 URL： 123import test from 'data:application/javascript;base64,ZXhwb3J0IGRlZmF1bHQgdHJ1ZTs=';console.log( test ); 然而我们一眼就能看出 Data URI 方式的缺陷：JavaScript 文件越来越大，URL 也就变得越来越长。以简明的方式将二进制数据转成 Data URI 也很困难。因此人们创造了 Object URI。它是几个标准的产物，包括 File API 和包括 和 的 HTML 5.x。Object URI 的目标很简单：从二进制数据生成虚拟文件，返回一个只在当前页面有效的唯一 URL。简单的说：在内存中创建一个具有唯一名称的文件。这样你就利用了 Data URI 的所有优势（用简单的方式创建新“文件”）又避免了它的缺陷（你不用在代码中包含可能多达 100MB 的文字了）。 流媒体（例如： 和 ）或者使用拖拽方式通过 input[type=file] 上传文件经常会创建 Object URI。不过你也可以用 File 和 Blob 类手动创建类似的文件。在这个案例中我们要把模块的内容储存在 Blog 类中并把它转换成 Object URI： 1234const myJSFile = new Blob( [ 'export default true;' ], { type: 'application/javascript' } );const myJSURL = URL.createObjectURL( myJSFile );console.log( myJSURL ); // blob:https://blog.comandeer.pl/8e8fbd73-5505-470d-a797-dfb06ca71333 动态导入不过还有一个问题：import 声明无法接收一个作为模块标识符的变量。这意味着你能把这个模块转换成“文件”却无法导入。到头来还是行不通？ 不是的。很早以前人们就注意到了这个问题并提出了动态导入提案。写这篇文章的时候（2018 年 8 月）已经进行到标准化的第三阶段了，在浏览器和其他 JavaScript 环境中已经开始部署。使用变量作为模块标识符以及动态导入已经没问题了： 123456const myJSFile = new Blob( [ 'export default true;' ], { type: 'application/javascript' } );const myJSURL = URL.createObjectURL( myJSFile );import( myJSURL ).then( ( module ) => { console.log( module.default ); // true} ); 可以看到，import() 的用法跟函数一样并返回一个 Promise，它是一个代表模块的对象。包含了所有声明过的导出项目，默认的导出项以 default 属性标识。 部署既然你已经知道你要做什么，那么就动手吧。添加下一个辅助函数 getSettings()。它会在 registerComponents() 之前被调用来从脚本中获取必须的信息： 12345678910111213function getSettings( { template, style, script } ) { return { template, style, script };}[…]function loadComponent( URL ) { return fetchAndParse( URL ).then( getSettings ).then( registerComponent );} 目前这个函数只是返回了所有传给它的参数。我们要把上面提到的整个的逻辑添加进去。首先，把脚本转成 Object URI： 12const jsFile = new Blob( [ script.textContent ], { type: 'application/javascript' } );const jsURL = URL.createObjectURL( jsFile ); 然后，通过 import 加载它并返回 template，styles 和从 中提取的组件名称。 1234567return import( jsURL ).then( ( module ) => { return { name: module.default.name, template, style }} ); 借助于此，registerComponent() 接收的 3 个参数里 变成了组件的名称。修改代码： 1234567function registerComponent( { template, style, name } ) { class UnityComponent extends HTMLElement { […] } return customElements.define( name, UnityComponent );} ＼( ｀∀´)／ Voilà! 行为层组件还有一部分没完成：行为，即处理事件。目前你只能从 getSettings() 函数获取组件的名字，你还需要获取事件监听器。Object.entries() 可以用来实现这个目的。我们回到 getSettings() 给它添加适当代码： 1234567891011121314151617181920212223242526function getSettings( { template, style, script } ) { […] function getListeners( settings ) { // 1 const listeners = {}; Object.entries( settings ).forEach( ( [ setting, value ] ) => { // 3 if ( setting.startsWith( 'on' ) ) { // 4 listeners[ setting[ 2 ].toLowerCase() + setting.substr( 3 ) ] = value; // 5 } } ); return listeners; } return import( jsURL ).then( ( module ) => { const listeners = getListeners( module.default ); // 2 return { name: module.default.name, listeners, // 6 template, style } } );} 函数变得复杂了。出现了新的辅助函数 getListeners() (1)。模块的 export 被传递给它(2)。然后使用 Object.entries() 遍历了这个 export 的所有属性(3)。如果当前属性名以 on... 开头(4)，就把这个属性的值赋给 listeners 对象，并把 setting[2].toLowerCase() + setting.substr(3) 作为它的属性名(5)。这个属性名是通过去掉 on 前缀后把首字母转换成小写（这样 onClick 会被转换成 click）得到的。然后把 listeners 对象传出去(6)。 可以用 [].reduce() 代替 [].forEach() 来处理 listeners 变量： 123456789function getListeners( settings ) { return Object.entries( settings ).reduce( ( listeners, [ setting, value ] ) => { if ( setting.startsWith( 'on' ) ) { listeners[ setting[ 2 ].toLowerCase() + setting.substr( 3 ) ] = value; } return listeners; }, {} );} 现在你可以在组件的 class 中绑定这些监听器了： 123456789101112131415161718function registerComponent( { template, style, name, listeners } ) { // 1 class UnityComponent extends HTMLElement { connectedCallback() { this._upcast(); this._attachListeners(); // 2 } […] _attachListeners() { Object.entries( listeners ).forEach( ( [ event, listener ] ) => { // 3 this.addEventListener( event, listener, false ); // 4 } ); } } return customElements.define( name, UnityComponent );} 重构过程中我们增加了一个新的参数 listeners (1)，以及 class 中的一个新的方法 _attachListeners (2)。我们又一次用到了 Object.entries()--这次是用来遍历 listeners (3) 并把它们绑定到这个组件元素上 (4)。 做完这些以后我们的组件应该会响应点击事件了： 点击了这个组件以后 Chrome 弹框显示：“Don’t touch me!” 以上就是如何实现一个单文件 Web Components 🎉! 浏览器兼容性以及其他你可以看出，即使是为了支持一个最简单形式的单文件组件，也需要做非常多的工作。我们所展现的这个系统中的许多部分都是用脏 hack 实现的（用 Object URI 来加载 ES 模块？--什么鬼！）而且如果没有浏览器的原生支持，这项技术也没什么意义。更重要的是，在我写这篇文章的时候（2018 年 8 月）Firefox 并不支持 Custom Elements 和 dynamic import。坦白说这东西现在只在 Chrome 里好使。因此--目前来说--它只是为了满足一下好奇心，没什么实际用处。 不过实现一个这样的东西还是很好玩的。它是一个涉及了许多浏览器开发和现代 web 标准相关内容的与众不同的小玩意儿。我希望至少能有一个人看完了这篇文章！ 当然了整个作品可以在网上预览。","link":"/2019/03/27/single-file-web-components/"},{"title":"「译」理解 JavaScript 中的 Promise","text":"作者：Gokul N K 原文链接：Understanding promises in JavaScript 我对 JavaScript 的感觉是“又爱又恨”。但是它还是一直吸引着我。我做了 10 年的 Java 和 PHP 开发，相较之下，JavaScript 是一个非常独特而有趣的存在。现在我正努力花时间来了解更多的 JavaScript 内容。 我遇到的第一个有意思的主题就是 Promise。曾经不止一次的听人们说起 Promise 把他们从回调地狱中拯救出来。而这只不过是 Promise 顺带的一点好处而已，Promise 包含了更多的内容，直到现在我才把它搞清楚。这是一篇长文，如果你想做些高亮标记什么的，你可以试试我们这个扩展 http://bit.ly/highlights-extension 背景第一次使用 JavaScript 的时候你可能会觉得很受挫。你可能会听到一些人说 JavaScript 是同步编程语言而另一些人则说它是异步的。你会听到诸如阻塞代码、非阻塞代码、事件驱动设计模式、事件生命周期、函数栈、事件队列、冒泡、polyfill、babel、angular、reactJS、VueJS 以及一大堆的工具和库。别担心，你不是第一个感觉头昏脑胀的人。有一个专门的名词，叫做 JavaScript Fatigue（JS 疲乏）。这条推特总结的很到位。 如果你想了解关于 JS 疲乏的更多细节，可以阅读下面这篇文章。这篇文章能在 Hackernoon 上获得 42000 次鼓掌不是没有原因的 :) JavaScript 是一个同步型的编程语言。不过借助于回调函数，我们可以让它像异步编程语言一样执行。 让门外汉理解 PromiseJavaScript 中的 Promise 跟现实生活中的 Promise 非常像。因此我们先来看一看现实生活中的承诺（Promise）是怎样的。 字典中是这样描述 Promise 的： Promise： 名词：某人保证会做某事或则某件事一定会发生。 那么当别人对你做了承诺（Promise）会发生什么呢？ Promise 是对某事一定会发生的保证。不论是（作出保证）的这个人亲自去做还是交由第三方去完成。然后你就可以在这个保证的基础上做下一步的计划。 Promise 会被实现或是没能实现。 当 Promise 实现时，会带回来某种结果。这个结果可被用于下一步的行动。 如果一个 Promise 未能成功实现，你会希望了解为何这个做出承诺的人未能履行他的诺言。一旦你了解并确认了 Promise 执行失败的原因，你就可以计划接下来如何处理它了。 在做出 Promise 的时候，我们得到的只是一个保证。除此之外我们暂时什么都做不了。不过我们可以先计划一下当 Promise 被实现以后（得到了我们预期的结果）或是 未能实现（了解失败原因并制定应急预案）时要做什么。 不过也有可能这个人在跟你做完 Promise 以后就杳无音讯了。这时候你需要设置一个时间节点。比如说如果这个做出承诺的人在 10 天之内没有回来我将假设他遇上了什么意外无法完成承诺了。因此即使这个人在 15 天之后才回来也没什么大不了，因为你已经制定了备用方案。 JavaScript 中的 Promise根据经验，我总是从 MDN Web Docs 阅读 JavaScript 的文档。我认为它最为精准权威。我通过阅读 MDN Web Docs 上的 Promise 相关页面 以及写代码实践来掌握它。 理解 Promise 分为两部分。创建 Promise 和 处理 Promise。尽管大多数情况下我们都是在写代码处理其他库产生的 Promise，全面的去了解 Promise 还是会很有帮助的。当你迈过初学者阶段以后你会发现了解“Promise 的创建”也是很重要的。 创建 Promise我们来看一下创建 Promise 的代码格式。 1234new Promise( /* 执行者 */ function(resolve, reject) { ... } ); 构造函数接受一个名为执行者（executor）的函数作为参数。executor 函数依次接受两个函数参数：resolve 和 reject。Promise 通常被用来简化异步操作或阻塞性代码的执行，这种操作一般出现在文件操作、API 调用、数据库调用、IO 调用等情景中。这些异步操作的初始化在 executor 函数中完成。如果异步操作成功完成，Promise 的创建者会调用 resolve 函数来返回操作结果。类似的，若因为发生了错误无法完成操作，失败原因会通过调用 reject 函数返回。 现在我们已经学会如何创建 Promise 了。我们来创建一个简单的 Promise 来帮助加深理解。 12345678910var keepsHisWord;keepsHisWord = true;promise1 = new Promise(function(resolve, reject) { if (keepsHisWord) { resolve(\"The man likes to keep his word\"); } else { reject(\"The man doesnt want to keep his word\"); }});console.log(promise1); 由于这个 Promise 在创建后立刻就被解决了（resolved），我们无法检测它的初始状态。所以我们再创建一个需要等待一段时间才会被 resolved 的 Promise。最简单的办法就是用 setTimeout 函数。 123456789promise2 = new Promise(function(resolve, reject) { setTimeout(function() { resolve({ message: \"The man likes to keep his word\", code: \"aManKeepsHisWord\" }); }, 10 * 1000);});console.log(promise2); 上面的代码创建了一个会在 10 秒钟后 resolve 的 Promise。因此我们可以在它 resolve 之前查看 Promise 状态。 10 秒种后 Promise 被 resolve。PromiseStatus 和 PromiseValue 也随之被更新。如你所见，我们修改了 resolve 函数以便传给它一个 JSON 对象而不仅仅是简单的文本。这是为了展现出我们可以向 resovle 函数传递不同的值。 现在我们来看一下被驳回（reject）的 Promise。我们对 Promise 1 做一点小小的修改。 123456789keepsHisWord = false;promise3 = new Promise(function(resolve, reject) { if (keepsHisWord) { resolve(\"The man likes to keep his word\"); } else { reject(\"The man doesn't want to keep his word\"); }});console.log(promise3); 由于我们创建了一个未处理的 rejection，Chrome 浏览器会显示一个错误。目前你可以先把它忽略，我们后面会处理这个错误。 我们看到，PromiseStatus 可以有不同的值：pending、resolved 或 rejected。在 Promise 创建时，PromiseStatus 处于 pending 状态，并且 PromiseValue 的值在 Promise 被 resolved 或 rejected 之前一直都是 undefined。当一个 Promise 处于 resolved 或 rejected 状态时，我们称这个 Promise 被解决了（settled）。所以通常来说，Promise 会从 pending 状态变成 settled 状态。 现在我们知道 Promise 是如何创建的了，我们可以看一下如何处理 Promise。这儿会手把手的教你理解 Promise 对象。 理解 Promise 对象据 MDN 文档 Promise 对象代表一个最终会实现（或失败）的异步操作，以及这个操作的返回值。 Promise 对象拥有静态方法以及 原型方法。Promise对象中的静态方法可以独立应用，而原型方法需要应用于Promise对象的实例。记住普通方法和原型方法都是返回一个 Promise 会对你的学习有所帮助。 原型方法我们先从三个原型方法开始。重申一下，所有这些方法都可以用于 Promise 对象的实例而且所有这些方法都会依次返回一个 Promise。前面我们已经看到，Promise 在刚创建时是处于 pending 状态。在 Promise 被解决（settled）以后，根据它的状态是 fulfilled 或 rejected，下面的某一个方法会被执行。 Promise.prototype.catch(onRejected) Promise.prototype.then(onFulfilled, onRejected) Promise.prototype.finally(onFinally) 下面的图片展示了 then 和 catch 方法的流程。图片中也显示了由于这些方法返回的是一个 Promise 因此可以被继续链下去。当在 Promise 上应用了 .finally 时，无论这个 Promise 的解决状态是 fulfilled 还是 rejected，它都会执行。 Konstantin Rouda 指出 finally 得到的支持非常有限，因此在使用它时请无比做好检测。 来源：https://mdn.mozillademos.org/files/15911/promises.png 讲个小故事。你是一个上学的孩子，正在跟你妈要一部手机。她说：“月底前我就给你买一部。” 我们来看一下如何用 JavaScript 来描述这个诺言在月底前被执行。 1234567891011121314151617181920212223242526var momsPromise = new Promise(function(resolve, reject) { momsSavings = 20000; priceOfPhone = 60000; if (momsSavings > priceOfPhone) { resolve({ brand: \"iphone\", model: \"6s\" }); } else { reject(\"We donot have enough savings. Let us save some more money.\"); }});momsPromise.then(function(value) { console.log(\"Hurray I got this phone as a gift \", JSON.stringify(value));});momsPromise.catch(function(reason) { console.log(\"Mom coudn't buy me the phone because \", reason);});momsPromise.finally(function() { console.log( \"Irrespecitve of whether my mom can buy me a phone or not, I still love her\" );}); 输出结果为： 如果我们把 momsSavings 的值设置为 200000，那么妈妈就有足够的钱给儿子买礼物了。这时输出如下： 我们来假装是这个库的用户。通过模拟它的特性和输出来研究如何有效的使用它并捕获错误。 由于 onFullfilled，onRejected 处理函数都可以由 .then 来处理，因此我们可以用下面这种写法来代替把 .then 和 .catch 分开写的做法。 12345678momsPromise.then( function(value) { console.log(\"Hurray I got this phone as a gift \", JSON.stringify(value)); }, function(reason) { console.log(\"Mom coudn't buy me the phone because \", reason); }); 不过从可读性的角度来说，我还是觉得分开写比较好。 为了确保上面所有的例子都能在常见浏览器或 Chrome 中执行，我的代码中没有任何外部依赖。为了加深对主题的理解，我们来创建一个会返回 Promise 的函数，这个 Promise 会被随机的成功执行（resolved）或执行失败（rejected），这样我们就可以在不同的情境下测试我们的代码。为了理解异步函数这一概念，我们的代码中还将加入随机的延迟。既然用到了随机，我们先来创建一个随机返回在 X 和 Y 之间的数值的函数。 1234function getRandomNumber(start = 1, end = 10) { //works when both start,end are >=1 and end > start return parseInt(Math.random() * end) % (end-start+1) + start;} 我们来创建一个返回 Promise 的函数。我们调用一下函数 promiseTRRARNOSG，它是函数 promiseThatResolvesRandomlyAfterRandomNumnberOfSecondsGenerator 的别名。这个函数会创建一个在 2 到 10 秒后被成功执行（resolved）或执行失败（rejected）的 Promise。为了使这个 Promise 的执行成功/失败随机化，我们会随机生成一个位于 1 到 10 之间的数字，如果数字大于 5，我们就让这个 Promise 成功执行（resolved），否则就让它执行失败（rejected）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344function getRandomNumber(start = 1, end = 10) { //works when both start and end are >=1 return (parseInt(Math.random() * end) % (end - start + 1)) + start;}var promiseTRRARNOSG = (promiseThatResolvesRandomlyAfterRandomNumnberOfSecondsGenerator = function() { return new Promise(function(resolve, reject) { let randomNumberOfSeconds = getRandomNumber(2, 10); setTimeout(function() { let randomiseResolving = getRandomNumber(1, 10); if (randomiseResolving > 5) { resolve({ randomNumberOfSeconds: randomNumberOfSeconds, randomiseResolving: randomiseResolving }); } else { reject({ randomNumberOfSeconds: randomNumberOfSeconds, randomiseResolving: randomiseResolving }); } }, randomNumberOfSeconds * 1000); });});var testProimse = promiseTRRARNOSG();testProimse.then(function(value) { console.log(\"Value when promise is resolved : \", value);});testProimse.catch(function(reason) { console.log(\"Reason when promise is rejected : \", reason);});// Let us loop through and create ten different promises using the function to see some variation. Some will be resolved and some will be rejected. for (i=1; i priceOfPhone) { resolve({ brand: \"iphone\", model: \"6s\" }); } else { reject(\"We donot have enough savings. Let us save some more money.\"); }});momsPromise.then(function(value) { console.log(\"Hurray I got this phone as a gift \", JSON.stringify(value));});momsPromise.catch(function(reason) { console.log(\"Mom coudn't buy me the phone because \", reason);});momsPromise.finally(function() { console.log( \"Irrespecitve of whether my mom can buy me a phone or not, I still love her\" );});momsPromise.then( function(value) { console.log(\"Hurray I got this phone as a gift \", JSON.stringify(value)); }, function(reason) { console.log(\"Mom coudn't buy me the phone because \", reason); });function getRandomNumber(start = 1, end = 10) { //works when both start,end are >=1 and end > start return parseInt(Math.random() * end) % (end-start+1) + start;}function getRandomNumber(start = 1, end = 10) { //works when both start and end are >=1 return (parseInt(Math.random() * end) % (end - start + 1)) + start;}var promiseTRRARNOSG = (promiseThatResolvesRandomlyAfterRandomNumnberOfSecondsGenerator = function() { return new Promise(function(resolve, reject) { let randomNumberOfSeconds = getRandomNumber(2, 10); setTimeout(function() { let randomiseResolving = getRandomNumber(1, 10); if (randomiseResolving > 5) { resolve({ randomNumberOfSeconds: randomNumberOfSeconds, randomiseResolving: randomiseResolving }); } else { reject({ randomNumberOfSeconds: randomNumberOfSeconds, randomiseResolving: randomiseResolving }); } }, randomNumberOfSeconds * 1000); });});var testProimse = promiseTRRARNOSG();testProimse.then(function(value) { console.log(\"Value when promise is resolved : \", value);});testProimse.catch(function(reason) { console.log(\"Reason when promise is rejected : \", reason);});// Let us loop through and create ten different promises using the function to see some variation. Some will be resolved and some will be rejected. for (i=1; i","link":"/2019/06/25/understanding-promise/"},{"title":"「译」5 分钟上手 Service Worker","text":"作者：Carmen Bourlon原文链接：Write Your First Service Worker in 5 Minutes 什么是 Service Worker?Service Worker 是一个让你可以在用户机器上缓存文件和其他资源的小文件。那它跟服务器端缓存 (server-side caching) 有什么区别呢？这种缓存是放在用户的机器上的，因此跟服务器端的缓存相比，它不需要再通过网络传输。这对提升你的应用的速度和可靠性是非常有好处的。由于 app 是从缓存中运行的，就不用大费周章的花时间从网络传输数据了。 为什么说它对你的应用有好处应用 Service Worker 不仅能提升应用的速度，还能为你的用户提供前所未有的可靠性。由于不再依赖实时的网络连接，应用在网络质量差的时候也能工作--说真的所有人的网络质量都不咋的。 生命周期Service Worker 生命周期基本是这样： install Activate Fetch 我们来分别讲解一下这些事件： Install在 install 事件之前，你的应用里还没有 Service Worker。浏览器会从你的代码中检测注册事件并安装 Service Worker。你的 Service Worker 包含一个名为 oninstall 的函数，它将决定哪些文件会被缓存到用户的机器上。 Activate在 Service Worker 安装就绪以后，会触发 activate 事件。此时是清理老旧无用的缓存文件的好时机。不过在这个例子中，我们并不会在 activate 事件里做任何操作。 Fetch这是我们的 Service Worker 大显身手的时候。当应用发出 fetch 请求时，我们的 Service Worker 会用一个名字也是 fetch 的函数拦截它。你的 Service Worker 会从换从中寻找类似的请求或是将这个请求发送出去。 Service Worker 生命周期中 activate 和 fetch 并不是依次执行的。Fetch 只有在有 fetch 操作时才执行拦截，因此 activate 事件和 ftech 事件之间是有间隔的。在这间隔期间，Service Worker 处于待命状态。 Service Worker 示例我们用 FayePI 来做例子。这是我写的一个帮助女性学习建设动态网站的 API，它的文档页面用了一点简单的 Service Worker。 为了安装 Service Worker，我们得先为应用添加一个注册函数。 12345// index.jsif(navigator.serviceWorker) { navigator.serviceWorker.register('serviceworker.js');} 上面这段代码通常放在 index.js 中以便在页面加载完成后立即执行。在你的应用代码中，这是唯一引用 Service Worker 的地方。 下面是我们的 Service Worker 文件。 123456789// serviceworker.jsself.oninstall = function() { caches.open('fayeFrontEndV1').then(function(cache) { cache.addAll([ / ... / ]) .catch( / ... / ); }) .catch( / ... /)} 这些就是安装 Sercice Worker 时执行的代码。首先我们初始化并打开 cache。我们在这里将文件缓存到用户机器上。 caches.open 返回一个包含我们打开的 cache 的引用的 promise。然后我们传给 addAll 函数一个字符串数组。这些字符串是我们要添加到缓存的文件的路径。最后我们添加几个 catch 函数来处理可能会出现的错误。 下一步是 activate: 1234// serviceworker.jsself.onactivate = function(event) { console.log('sw is up and running!');} 此时是进行垃圾清理的好时机，不过我们将在另一篇博文里讲解。 最后，也是最棒的部分！让我们来看看 fetch。 12345678910111213// serviceworker.jsself.onfetch = function(event) { event.respondWith( caches.match(event.request) .then(function(cachedFiles) { if(cachedFiles) { return cachedFiles; } else { return fetch(event.request); } }) );} 这个函数会在 Service Worker 检测到 fetch 请求时执行。它会在全部 cache 中试图找到匹配的请求。如果匹配成功，函数将返回 cache 中的结果。否则 Service Worker 会发送网络请求。 让我们仔细分析一下 event.respondWith 和 caches.match，这俩都是 Service Worker 专有的。 event.respondWith 让你可以打断 fetch 请求并返回你自己的响应内容。一定要注意必须用这个方法而不是简单的 return 一个返回值，只有这样你拦截的回复才能发送到正确的地方。 caches.match 让你能够搜索 CacheStorage 并找到请求的匹配项。我们向 cache 添加的内容，会被存储到一个栈中，最早添加的在最底部，最后添加的在顶部。caches.match 会返回最新的匹配项。如果没有匹配项，则返回 null。 大功告成！以上就是一个简单的 Service Worker 的全部内容！如果你觉得 Service Worker 超级酷，我推荐你了解一下它还能做什么，包括后台 fetch，在这篇博客中。 如果你想学习更多关于 Service Worker 的知识，我希望你能去 serviceworkerbook.com 并订阅我的邮件列表，并在 Twitter 关注我！你会在我的书 “Let’s Take This Offline” 出版的第一时间获悉！","link":"/2019/03/31/sw-in-5m/"},{"title":"「译」深度理解 JavaScript ES6 中的 “Super” 和 “Extends”","text":"作者：Anurag Majumdar原文链接：“Super” and “Extends” In JavaScript ES6 - Understanding The Tough Parts ES6 的 class 语法以及其他新特性让 JavaScript 显得简单多了。今天我们将结合 class 语法和继承概念来分析一些代码。猜的没错，我们要研究的正是 ES6 中的 super 和 extends 关键字。学习新特性最好的方式就是在实例中深入的研究它。让我们开始吧！ 在代码中使用 super 和 extends我们可以借助 super 和 extends JavaScript 中扩展一个 class。来看一下下面的例子中是如何使用这两个关键字的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Animal { constructor(name, weight) { this.name = name; this.weight = weight; } eat() { return `${this.name} is eating!`; } sleep() { return `${this.name} is going to sleep!`; } wakeUp() { return `${this.name} is waking up!`; }}class Gorilla extends Animal { constructor(name, weight) { super(name, weight); } climbTrees() { return `${this.name} is climbing trees!`; } poundChest() { return `${this.name} is pounding its chest!`; } showVigour() { return `${super.eat()} ${this.poundChest()}`; } dailyRoutine() { return `${super.wakeUp()} ${this.poundChest()} ${super.eat()} ${super.sleep()}`; }}function display(content) { console.log(content);}const gorilla = new Gorilla('George', '160Kg');display(gorilla.poundChest());display(gorilla.sleep());display(gorilla.showVigour());display(gorilla.dailyRoutine());// OUTPUT:// George is pounding its chest!// George is going to sleep!// George is eating! George is pounding its chest!// George is waking up! George is pounding its chest! George is eating! George is going to sleep! ES6 Class 及 Subclass 语法 上面的代码中有两个 JavaScript class，分别叫做 Animal 和 Gorilla。 Gorilla class 通过使用 extends 关键字将自己设置为 Animal class 的附属类，或者也可以称之为子类。 不过，不知道你有没有注意到，super 关键字在这里有两种不同的用法。在 Gorilla 构造函数中（代码 23 行），super 被当作方法使用，然而在 Gorilla 的 showVigour() 方法（代码 35 行）及 dailyRoutine() 方法（代码 39 行）中 super 却是被当作“对象”使用的。 super 关键字有两种不同用法的原因是：在第 23 行中，super 关键字是作为一个函数，它使用传递给 Gorilla 的参数来调用父类 Animal。这是确保 Gorilla 是 Animal 的实例的关键一步。在第 35 行和第 39 行中，Super 被用作是一个对象，来引用一个 Animal 实例（父类）。这里的 super 关键字用来显式的调用父类 Animal 的方法。 熟悉 C#、JAVA、Python 等语言的人应该能明白这是怎么回事。不过，在 ES6 出现之前 JavaScript 可没这么简明，特别是在类这个问题上。那么在没有 class 语法、super 及 extends 关键字的年代人们是怎么写代码的呢？还是这群从未用过以上概念的人突发奇想的要添加这些特性？让我们来探寻一下！ 传统的 JavaScript 类事实上，面向对象的 JavaScript 使用原型继承来扩展类。我们来看一下用传统的 JavaScript 语法来写上面的例子。也许这将帮你找到隐藏的真相。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556function Animal(name, weight) { this.name = name; this.weight = weight;}Animal.prototype.eat = function() { return `${this.name} is eating!`;}Animal.prototype.sleep = function() { return `${this.name} is going to sleep!`;}Animal.prototype.wakeUp = function() { return `${this.name} is waking up!`;}function Gorilla(name, weight) { Animal.call(this, name, weight);}Gorilla.prototype = Object.create(Animal.prototype);Gorilla.prototype.constructor = Gorilla;Gorilla.prototype.climbTrees = function () { return `${this.name} is climbing trees!`;}Gorilla.prototype.poundChest = function() { return `${this.name} is pounding its chest!`;}Gorilla.prototype.showVigour = function () { return `${Animal.prototype.eat.call(this)} ${this.poundChest()}`;}Gorilla.prototype.dailyRoutine = function() { return `${Animal.prototype.wakeUp.call(this)} ${this.poundChest()} ${Animal.prototype.eat.call(this)} ${Animal.prototype.sleep.call(this)}`;}function display(content) { console.log(content);}var gorilla = new Gorilla('George', '160Kg');display(gorilla.poundChest());display(gorilla.sleep());display(gorilla.showVigour());display(gorilla.dailyRoutine());// OUTPUT:// George is pounding its chest!// George is going to sleep!// George is eating! George is pounding its chest!// George is waking up! George is pounding its chest! George is eating! George is going to sleep! ES6 出现之前面向对象的 JavaScript 看完上面的代码以后你们一定在想，等一下，这里面怎么没有 class？也没有 constructor？这些古老的 JavaScript 代码是如何做到在不使用 extends 和 super 关键字的情况下实现继承的？这样写代码不是很丑嘛？ 没错儿我完全理解你们的感受。很不幸，JavaScript 的底层实现从未变过。不管有多少新特性被添加，它的底层仍然是老样子。class、constructor、super 和 extends 等关键字只是为他添加了一些语法糖，以使得代码可读性更好也更易于编写。 让我来解释一下 ES6 哪些代码对应了传统的 JavaScript 代码。 如果你是初次接触 JavaScript 中的 prototype 和 inheritance 概念，请先阅读下面两篇文章后再继续阅读本文剩下的章节： 这两篇参考文章对你更好的理解下面的章节会有很大帮助。 ES6 与传统 JavaScript 代码对比下面的章节回分解对比 ES6 代码与传统 JavaScript 风格代码的异同。 类声明下面的代码片段对比了两种类声明方式。 1234567891011121314151617// ES6 styleclass Animal { constructor(name, weight) { this.name = name; this.weight = weight; } //...}// Check Type of ES6 classtypeof Animal // function// Traditional stylefunction Animal(name, weight) { this.name = name; this.weight = weight;} 类声明对比 ES6 的类声明直接使用 class 关键字，然后在 constructor （构造函数）中定义实例变量。而在传统的 JavaScript 中是没有 class 这种东西的。实际上在 JavaScript 内部 class 就是一个函数（参见代码片段第 11 行）。 第 3 行的 constructor 函数跟第 14 行的函数是一样的。这里的 Animal 函数就相当于 constructor 函数。 Class 中的方法12345678910111213141516171819202122232425// ES6 styleclass Animal { // ... eat() { return `${this.name} is eating!`; } sleep() { return `${this.name} is going to sleep!`; } wakeUp() { return `${this.name} is waking up!`; } // ...}// Traditional styleAnimal.prototype.eat = function() { return `${this.name} is eating!`;}Animal.prototype.sleep = function() { return `${this.name} is going to sleep!`;} 方法声明对比 从第 4 行到第 14 行是 ES6 风格的类中的方法。不过在传统的 JavaScript 是不可能这样写的，因为根本就不存在 class 这个东西来让你轻松的声明方法。在传统的 JavaScript 中，我们通过把方法添加到 prototype 上来达到为类添加方法这一目的。第 19 行到第 29 行是为传统 JavaScript 类添加方法的写法。 extends 在传统 JavaScript 中的对应当我们要从父类扩展一个子类时，两种写法的差异就更大了。参见下面的代码片段： 123456789101112131415// ES6 styleclass Gorilla extends Animal { constructor(name, weight) { super(name, weight); } //...}// Traditional stylefunction Gorilla(name, weight) { Animal.call(this, name, weight);}Gorilla.prototype = Object.create(Animal.prototype);Gorilla.prototype.constructor = Gorilla; extends 关键字与传统实现方式的对比 我们看到 extends 关键字用 ES6 的风格处理了从父类 Animal 扩展出子类的操作，不过这里也用到了 super 关键字来确保 Gorilla 的构造函数调用了 Animal 类，这样它就能继承 Animal 的特性和行为。在这里，super 关键字是作为函数来调用 Animal 类来初始化 Gorilla。这时候，super 的作用相当于 Animal.call(this,…)。 若是用传统的写法来实现继承，则要多几个步骤。首先要创建一个子类 Gorilla 的函数，如代码第 10 行所示。由于 Gorilla 要继承 Animal 的特性和行为，它需要在 Gorilla 的构造函数中调用 Animal 的构造函数，如代码第 11 行所示，这行与第 4 行的功能是一样的。只不过我们需要显式的传递 “this” 引用给 Animal 类以保证调用是在 Gorilla 中发生的。 不仅如此，我们还需要将 Gorilla 函数的 prototype 设置为一个从 Animal 的 prototype 创建的新对象，如代码第 11 行所示。这样一来，我们就重写了 Gorilla 的 prototype 对象。所以，我们需要在代码第 15 行中显式的设置 Gorilla 的构造函数。通过这些步骤我们将 Gorilla 类设置成为 Animal 类的子类。 super 在传统 JavaScript 中的对应我们已经见识过 super 关键字的一种对应，即，下面代码片段第 4 行和第 19 行，super 被用作函数。 1234567891011121314151617181920212223242526272829// ES6 styleclass Gorilla extends Animal { constructor(name, weight) { super(name, weight); } showVigour() { return `${super.eat()} ${this.poundChest()}`; } dailyRoutine() { return `${super.wakeUp()} ${this.poundChest()} ${super.eat()} ${super.sleep()}`; } // ...}// Traditional stylefunction Gorilla(name, weight) { Animal.call(this, name, weight);}Gorilla.prototype = Object.create(Animal.prototype);Gorilla.prototype.constructor = Gorilla;Gorilla.prototype.showVigour = function () { return `${Animal.prototype.eat.call(this)} ${this.poundChest()}`;}Gorilla.prototype.dailyRoutine = function() { super 关键字与传统实现方式的对比 super 关键字也可以用作父类的实例，如代码第 8 行和第 12 行这样调用 Animal 类的方法。 代码第 26 行展示了在传统的 JavaScript 中实现同样的目的，super 实例相当于传统写法的 ParentClassName.prototype.methodName.call(this, …)。即传统写法需要编写大量的代码来确保父类的方法被调用。 结论我很确定，你们在了解了传统的写法是多么的复杂之后一定会毫不犹豫的选择 ES6 的类和继承特性。而且，Chrome 和 Firefox 已经支持了 ES6，不过为了确保 ES6 特性在所有的浏览器中都能执行，你还是需要一个 babel 转译器来把 ES6 代码转换成 ES5 代码。 祝编码快乐！😄","link":"/2019/05/27/super-extends-js/"},{"title":"「译」如何制作 SVG 线条动画","text":"作者：Chris Coyier原文链接：Write Your First Service Worker in 5 Minutes 我敢说你们都见过那种看起来如同正在实时绘制 SVG 图形的 SVG 小动画。效果非常的赞。Jake Archibald 是这门技巧的先驱，他还写了一篇超级棒的引人入胜的博客来说明如何实现这种效果。Brian Suda 也在 24 Ways 上面写了一篇文章。Polygon 使用这项技术来为他们的设计添加惊艳的效果并写了一篇文章来说明。Codrops 上有一些简洁的例子。 我基本上没有什么可以再补充了，只不过我的大脑刚刚弄明白，所以我想再解释一遍我的理解。 1. 你有一个 SVG 图形 2. 图形必须有线条（stroke） 3. 线条可以被设置成线段模式我们可以用 Illustrator 实现，也可以通过编程的方式实现。我们用 CSS 来选中图形路径（这里我们假设我们用的是 inline SVG 或者是一个 object 元素）并应用线段样式。 123 123.path { stroke-dasharray: 20;} 这样我们就设置了长度为 20px 的线段样式。 4. 线段也可以设置的更长一点…123.path { stroke-dasharray: 100;} 5. 我们还可以 “offset” 这些线段，以便让它们移动位置来看一下我们把这些线段的 offset 动画以后的效果： 实现起来很简单 12345678910.path { stroke-dasharray: 100; animation: dash 5s linear;}@keyframes dash { to { stroke-dashoffset: 1000; }} 6. 设想一下单个线段长度足以覆盖整个图形这个就不用放图了，它看起来就是图形没有线段化的样子。你只需要把 stroke-dasharry 设置成一个比整个图形更长的长度。 7. 现在给线条设置 offset，让它完全消失在图形范围内而不是覆盖整个图形。现在整个图形看起来仿佛不存在。 8. 现在动画 offset 属性并将它设置为 0 如果是使用 CSS，你需要将 animation-fill-mode 设置为 forwards，这样动画结束时会保持在完成状态。 1234567891011.path { stroke-dasharray: 1000; stroke-dashoffset: 1000; animation: dash 5s linear forwards;}@keyframes dash { to { stroke-dashoffset: 0; }} 齐活儿！ 为什么要用 JavaScript？大多数你见到的 SVG 线条动画都使用了 JavaScript。这是因为我们一般很难知道图形的具体长度。我们在例子中使用 1000 是因为这刚巧就是图形的长度。 你可以用 JavaScript 获取图形长度： 12var path = document.querySelector('.path');var length = path.getTotalLength(); 然后就可以随心所欲的使用了。本文开头提到的那些文章中有更多更深入的信息，你可以参考那些内容去实现更酷炫的效果。这里我只是概括一些概念要点，或许也能帮助你悟通 SVG 线条动画。","link":"/2020/01/30/svg-line-animation/"},{"title":"「译」使用 CSS 硬件加速提升网站性能","text":"作者： Guil Hernandez 原文链接：Increase Your Site’s Performance with Hardware-Accelerated CSS 你知道我们可以把图像相关的 CSS 特性交给 GPU(图像处理单元) 处理，以利用硬件加速在浏览器中获得更好的渲染性能吗？ 当今的大多数电脑都有可用于硬件加速的显卡。因此，我们可以利用这些 GPU 资源去处理那些比较耗性能的特性，这样我们的网站和应用在浏览器中就能获得比单纯用 CPU 处理更好的性能表现。 这篇文章里，我们会讲到桌面和手机端浏览器的 CSS 硬件加速。 桌面和手机端浏览器中的 CSS 硬件加速你有没有想过为什么有些 CSS 动画在浏览器中看起来比其他的更流畅些？ CSS animations, transforms 和 transitions 默认并不会启用 GPU 加速，而是被浏览器内部的（比较慢的）软件引擎渲染。那么到底是什么强制浏览器切换到 GPU 模式呢？许多浏览器通过一些特定的 CSS 规则启用 GPU 加速。 当前，Chrome, Firefox, Safari, IE9+ 和最新版的 Opera 都支持硬件加速；它们只有在检测到某个 DOM 元素可能会从中获益的时候才会应用硬件加速。在 CSS 中，最显眼的迹象就是这个元素使用了 3D 变换。 例如： 12345.cube { -webkit-transform: translate3d(250px,250px,250px) rotate3d(250px,250px,250px,-120deg) scale3d(0.5, 0.5, 0.5);} 某些时候，你可能并不需要 3D 变换但仍然想利用硬件加速。这时候有几个非常顺手的 CSS 特性可以用来触发浏览器的 GPU 加速。 尽管我们的元素并不是在 3D 空间中做动画，我们仍然可以启用 3D 渲染。闲话休提，transform: translateZ(0); 声明在桌面和手机端浏览器中都会触发 GPU 加速。看起来这是触发 GPU 加速的最有效的方式了（添加了所有浏览器前缀）： 12345678.cube { -webkit-transform: translateZ(0); -moz-transform: translateZ(0); -ms-transform: translateZ(0); -o-transform: translateZ(0); transform: translateZ(0); /* Other transform properties here */} 在 Chrome 和 Safari 中使用 CSS transforms 时可能会有闪烁。下面这些声明可以解决这个问题： 123456789101112.cube { -webkit-backface-visibility: hidden; -moz-backface-visibility: hidden; -ms-backface-visibility: hidden; backface-visibility: hidden; -webkit-perspective: 1000; -moz-perspective: 1000; -ms-perspective: 1000; perspective: 1000; /* Other transform properties here */} 另一种可以用在 Webkit 内核的桌面和手机浏览器中的方法是使用 translate3d： 1234567.cube { -webkit-transform: translate3d(0, 0, 0); -moz-transform: translate3d(0, 0, 0); -ms-transform: translate3d(0, 0, 0); transform: translate3d(0, 0, 0); /* Other transform properties here */} 原生的手机应用一直在利用 GPU 加速，这也就是为什么大家一直以来的印象都是原生应用要比网页应用更流畅一些。在手机上使用硬件加速来降低资源消耗是非常有必要的。 结论我们介绍的这些方法应该只用于需要动画的元素。这可以提高 2D 变换的性能，不过把这种方法用于所有元素绝不是一个好主意。 谨慎使用这些方法，只有当你遇到性能瓶颈时才需要用它们。滥用 GPU 加速将导致严重的性能问题，因为硬件加速会占用大量内存 -- 而且还会影响电池续航。 你在你的项目中用过这些方法吗？如果用过，请分享一下哪些方法最有效性能最好。","link":"/2019/03/26/css-hardware-accelerate/"},{"title":"「译」Web Components：入门到精通 (1)","text":"作者：Pascal Schilp原文链接：Web Components: from zero to hero Web Components: 入门到精通一个编写原生 Web Components 的教程 什么是 Web Components？ 组件生命周期 编写我们的 to-do 应用 设置 properties 设置 attributes 将 properties 映射到 attributes 事件 浏览器支持以及 polyfill 包装 Web Components 现在有了越来越大的推动力。随着 Edge 团队宣布部署 Custom Elements 和 Shadow DOM，所有的主流浏览器都已经原生支持 Web Components。像 Github，Netflix，Youtube 和 ING 等甚至已经在生产环境中使用了 Web Components！赞！不过，很让人惊讶的是，这些成功的大公司中没有一个做过（猜的没错） to-do 应用！ 因此，今天我们要做一个 to-do 应用，因为世界上还没几个 to-do 应用。你可以在这里先预览一下我们要做的东西。 在开始之前，我要先写点免责声明，这篇博文只是为了让你对 Web Components 的基础概念有个大概的了解。Web Components 是非常底层的技术，并不建议在没有辅助库的情况下编写完整的应用，也不应该拿它跟其他成熟的框架进行比较。 什么是 Web Components？先说重点：Web Components 是一系列编写具有模块化、可重用和封装性的 HTML 元素的规范。最棒的地方在于：由于它是基于 web 标准，我们无需安装任何框架或库。现在你就可以用纯 JavaScript 编写 Web Components！ 不过呢，在我们下手之前，让我们先来看看编写 Web Components 的县官规范。 自定义元素Custom Elements api 允许我们编写自定义的 DOM 元素。通过这个 api，我们可以定义一个自定义元素，并通知解析器如何正确的构建元素及如何应对此类元素的变动。你是否想过创建自己的元素，比如 ？现在你能够这样做了！ Shadow DOMShadow DOM 给了我们封装组件样式和标记的能力。它是一个 DOM 元素的子 DOM 树，可以确保我们的组件样式不会泄漏到外部作用域，或是被外部作用域的样式所影响。是模块化的绝配。 ES 模块ES 模块规范定义了标准化、模块化、高效率的引用和重用 JS 文件的方式。 HTML TemplatesHTML 标签允许我们创建可重用的 DOM 块。在 template 内部，脚本不会执行，图片不会加载，样式和标签也不会渲染。在这个 template 被激活之前它甚至会被当作不存在在 document 中。HTML templates 非常棒，因为不管我们这个自定义元素有多少实例，它们用的都是同一个 template。 现在我们已经知道了 Web Components 利用了哪些 Web 规范，我们来看一下自定义元素的生命周期。别急，别急，我们马上就要开始写代码了！ 组件的生命周期我们来看一下自定义元素的生命周期。以下面的元素为例： 12345678910111213141516171819202122232425class MyElement extends HTMLElement { constructor() { // 务必先调用 super() super(); console.log('constructed!'); } connectedCallback() { console.log('connected!'); } disconnectedCallback() { console.log('disconnected!'); } attributeChangedCallback(name, oldVal, newVal) { console.log(`Attribute: ${name} changed!`); } adoptedCallback() { console.log('adopted!'); }}window.customElements.define('my-element', MyElement); constructor()constructor 会在元素创建后而尚未被附加到文档上之前被调用。我们用 constructor 来设置初始状态、事件监听以及 shadow DOM。 connectCallback()connectCallback 会在元素被添加到 DOM 中后被调用。此时非常适合执行初始化代码，比如获取数据或是设置默认属性。 disconnectedCallback()disconnectedCallback() 会在元素从 DOM 中被移除后调用。大扫除时间！我们可以利用 disconnectedCallback 来移除事件监听器或取消定时循环事件。 attributeChangedCallback(name, oldValue, newBalue)attributeChangedCallback 会在元素的受监的控属性变动时被调用。我们可以通过设置 observedAttributes getter 来监控某个元素属性，像这样： 123static get observedAttributes() { return ['my-attr'];} 在这个例子中，每当 my-attr 属性发生变化，attributeChangedCallback 就会执行。本文后面将会详细讲解。","link":"/2019/04/01/web-components-hero-1/"}],"tags":[{"name":"VueJS","slug":"VueJS","link":"/tags/VueJS/"},{"name":"jQuery","slug":"jQuery","link":"/tags/jQuery/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"Promise","slug":"Promise","link":"/tags/Promise/"},{"name":"async","slug":"async","link":"/tags/async/"},{"name":"await","slug":"await","link":"/tags/await/"},{"name":"Web Components","slug":"Web-Components","link":"/tags/Web-Components/"},{"name":"Javascript","slug":"Javascript","link":"/tags/Javascript/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"Service Worker","slug":"Service-Worker","link":"/tags/Service-Worker/"},{"name":"App","slug":"App","link":"/tags/App/"},{"name":"JS 应用","slug":"JS-应用","link":"/tags/JS-%E5%BA%94%E7%94%A8/"},{"name":"应用","slug":"应用","link":"/tags/%E5%BA%94%E7%94%A8/"},{"name":"Web 开发","slug":"Web-开发","link":"/tags/Web-%E5%BC%80%E5%8F%91/"},{"name":"Super","slug":"Super","link":"/tags/Super/"},{"name":"Extends","slug":"Extends","link":"/tags/Extends/"},{"name":"JS对象","slug":"JS对象","link":"/tags/JS%E5%AF%B9%E8%B1%A1/"},{"name":"SVG","slug":"SVG","link":"/tags/SVG/"},{"name":"SVG 动画","slug":"SVG-动画","link":"/tags/SVG-%E5%8A%A8%E7%94%BB/"},{"name":"SVG Animation","slug":"SVG-Animation","link":"/tags/SVG-Animation/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"Hardware accelerate","slug":"Hardware-accelerate","link":"/tags/Hardware-accelerate/"},{"name":"硬件加速","slug":"硬件加速","link":"/tags/%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F/"}],"categories":[]}