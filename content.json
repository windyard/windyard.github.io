{"pages":[],"posts":[{"title":"「译」使用 CSS 硬件加速提升网站性能","text":"作者： Guil Hernandez 原文链接：Increase Your Site’s Performance with Hardware-Accelerated CSS 你知道我们可以把图像相关的 CSS 特性交给 GPU(图像处理单元) 处理，以利用硬件加速在浏览器中获得更好的渲染性能吗？ 当今的大多数电脑都有可用于硬件加速的显卡。因此，我们可以利用这些 GPU 资源去处理那些比较耗性能的特性，这样我们的网站和应用在浏览器中就能获得比单纯用 CPU 处理更好的性能表现。 这篇文章里，我们会讲到桌面和手机端浏览器的 CSS 硬件加速。 桌面和手机端浏览器中的 CSS 硬件加速你有没有想过为什么有些 CSS 动画在浏览器中看起来比其他的更流畅些？ CSS animations, transforms 和 transitions 默认并不会启用 GPU 加速，而是被浏览器内部的（比较慢的）软件引擎渲染。那么到底是什么强制浏览器切换到 GPU 模式呢？许多浏览器通过一些特定的 CSS 规则启用 GPU 加速。 当前，Chrome, Firefox, Safari, IE9+ 和最新版的 Opera 都支持硬件加速；它们只有在检测到某个 DOM 元素可能会从中获益的时候才会应用硬件加速。在 CSS 中，最显眼的迹象就是这个元素使用了 3D 变换。 例如： 12345.cube &#123; -webkit-transform: translate3d(250px,250px,250px) rotate3d(250px,250px,250px,-120deg) scale3d(0.5, 0.5, 0.5);&#125; 某些时候，你可能并不需要 3D 变换但仍然想利用硬件加速。这时候有几个非常顺手的 CSS 特性可以用来触发浏览器的 GPU 加速。 尽管我们的元素并不是在 3D 空间中做动画，我们仍然可以启用 3D 渲染。闲话休提，transform: translateZ(0); 声明在桌面和手机端浏览器中都会触发 GPU 加速。看起来这是触发 GPU 加速的最有效的方式了（添加了所有浏览器前缀）： 12345678.cube &#123; -webkit-transform: translateZ(0); -moz-transform: translateZ(0); -ms-transform: translateZ(0); -o-transform: translateZ(0); transform: translateZ(0); /* Other transform properties here */&#125; 在 Chrome 和 Safari 中使用 CSS transforms 时可能会有闪烁。下面这些声明可以解决这个问题： 123456789101112.cube &#123; -webkit-backface-visibility: hidden; -moz-backface-visibility: hidden; -ms-backface-visibility: hidden; backface-visibility: hidden; -webkit-perspective: 1000; -moz-perspective: 1000; -ms-perspective: 1000; perspective: 1000; /* Other transform properties here */&#125; 另一种可以用在 Webkit 内核的桌面和手机浏览器中的方法是使用 translate3d： 1234567.cube &#123; -webkit-transform: translate3d(0, 0, 0); -moz-transform: translate3d(0, 0, 0); -ms-transform: translate3d(0, 0, 0); transform: translate3d(0, 0, 0); /* Other transform properties here */&#125; 原生的手机应用一直在利用 GPU 加速，这也就是为什么大家一直以来的印象都是原生应用要比网页应用更流畅一些。在手机上使用硬件加速来降低资源消耗是非常有必要的。 结论我们介绍的这些方法应该只用于需要动画的元素。这可以提高 2D 变换的性能，不过把这种方法用于所有元素绝不是一个好主意。 谨慎使用这些方法，只有当你遇到性能瓶颈时才需要用它们。滥用 GPU 加速将导致严重的性能问题，因为硬件加速会占用大量内存 -- 而且还会影响电池续航。 你在你的项目中用过这些方法吗？如果用过，请分享一下哪些方法最有效性能最好。","link":"/2019/03/26/css-hardware-accelerate/"},{"title":"Testing post","text":"This is a testing post.Created at February 7th, 2019, 21:26","link":"/2019/02/07/Testing-post/"},{"title":"Hello World 2","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/02/02/hello-world/"},{"title":"「译」 如何在 Vue 中（安全的）使用 jQuery 插件","text":"作者：Anthony Gore 原文链接：How To (Safely) Use A jQuery Plugin With Vue.js 在一个 UI 中同时使用 Vue.js 和 jQuery 并不是一个好主意。如果可能的话要避免这种情形。 不过既然你已经看到这里了，估计你是非要同时用 Vue 和 jQuery 不可了。或许是客户坚持要使用某个 jQuery 插件而你又没时间去把它用 Vue 重写。 只要你谨慎的操作，还是可以同时使用 Vue 和 jQuery 的。这篇文章里我将演示如何在 Vue 项目中使用一个 jQuery UI 的 Datepicker 插件。 而且为了小小的炫一下技，我还要在 jQuery 插件和 Vue 之间传递数据！ 点击这里查看示例代码 JS Bin jQuery UI Datepicker 同时使用 jQuery 和 Vue 存在的问题为什么说这种用法会有潜在的风险呢？ 可以说 Vue 是一个占有欲非常强的框架，她总想完全控制你交给她的这部分 DOM 元素（传递给 el 属性的元素）。如果 jQuery 修改了 Vue 管辖下的元素，例如为某个元素添加了一个 class， Vue 无法感知到这次修改，所以下次 Vue 更新 DOM 时会直接覆盖 jQuery 所做的修改。 解决方案：把 jQuery 插件包装成 Vue 组件既然 Vue 和 jQuery 绝不会分享同一份 DOM，我们必须让 Vue 分割出一块区域交给 jQuery。 看起来把 jQuery 插件包装成 Vue 组件是个办法，因为： 我们可以利用 Vue 生命周期勾子来设置或卸载 jQuery 代码 我们可以通过组件接口使用 props 和 events 来与 Vue 应用通信 组件可以通过设置 v-once 避免被 Vue 更新 设置 jQuery UI Datepicker首先要做的当然是在你的项目中引入 jQuery UI 插件。然后你只需要把 datepicker 插件绑定到一个 input 元素上： 1Date: &lt;input id=\"datepicker\"&gt; 选中并初始化 Datepicker 1$('#datepicker').datepicker(); Datepicker 组件我们的 datepicker 组件很简单，template 只有一个 input 元素： 1234567Vue.component('date-picker', function() &#123; template: '&lt;input/&gt;'&#125;);new Vue(&#123; el: '#app'&#125;); 123&lt;div id=\"app\"&gt; Date: &lt;date-picker&gt;&lt;/date-picker&gt;&lt;/div&gt; 注意：组件只是为 jQuery 插件提供一个包装。不要试图为组件元素添加任何 data 属性或 Vue directives 或 slots。 插件实例化在这里我们将使用 this.$el 而不是 input 元素的 ID 来选择插件元素，每个 Vue 组件都可以像这样来访问到自己的根元素。我们这里的根元素就是 input。 然后我们可以把这个元素引用传递给 jQuery 选择器并调用 datepicker 方法。例：$(this.$el).datepicker()。 注意我们的代码是写在在 Vue 组件生命周期的 mounted 阶段，因为在此之前 this.$el 还是 undefined 状态。 123456Vue.component('date-picker', function() &#123; template: '&lt;input/&gt;', mounted: function() &#123; $(this.$el).datepicker(); &#125;&#125;); 卸载类似的，卸载 datepicker 插件同样也会用到生命周期勾子。注意我们必须在 beforeDestroy 阶段执行卸载，因为在这个阶段 input 元素仍然存在于 DOM 中，我们才能选中它（在 destroy 阶段它将变成 undefined）。 123456789Vue.component('date-picker', &#123; template: '&lt;input/&gt;', mounted: function() &#123; $(this.$el).datepicker(); &#125;, beforeDestroy: function() &#123; $(this.$el).datepicker('hide').datepicker('destroy'); &#125;&#125;); 通过 props 传递参数为了使我们的组件可复用，最好让它能接受自定义设置参数，例如通过设置属性 dateFormat 来制定日期格式。通过 props 可以实现这一目标： 12345678910Vue.component('date-picker', &#123; template: '&lt;input/&gt;', props: [ 'dateFormat' ], mounted: function() &#123; $(this.$el).datepicker(&#123; dateFormat: this.dateFormat &#125;); &#125;, beforeDestroy: function() &#123; ... &#125;&#125;); 123&lt;div id=\"app\"&gt; &lt;date-picker date-format=\"yy-mm-dd\"&gt;&lt;/date-picker&gt;&lt;/div&gt; 让 jQuery 接收更新比方说你不满足于只是传给 dateFormat prop 一个字符串，而是把 dateFormat 设置成 Vue 根实例上的一个属性，例： 123456var vm = new Vue(&#123; data: &#123; ... dateFormat: 'yy-mm-dd' &#125;&#125;); 123&lt;div id=\"app\"&gt; &lt;date-picker date-format=\"dateFormat\"&gt;&lt;/date-picker&gt;&lt;/div&gt; 这样一来，dateFormat 就变成了一个响应式的 data 属性。你可以随时在应用中更改它的值： 12// 更改日期显示格式vm.dateFormat = 'yy-dd-mm'; 由于 dateFormat prop 是 datepicker 组件的 mounted 钩子的依赖项，更新它的值将导致组件重新渲染。这就不妙了。因为 jQuery 已经在 input 元素上设置好了 datepicker 并且添加了自己的 class 和 事件监听。组件重新渲染将导致 input 元素被替换而且 jQuery 所做的设置也被重置了。 我们需要将组件设置为接收数据不重新渲染… v-oncev-once 指令用于缓存一个包含大量静态内容的组件。导致的结果就是这个组件渲染不会受数据更新的影响。 我们的组件正好用到这个特性，因为它有效的避免了被 Vue 重新渲染。因此我们有理由相信 jQuery 将可以在应用的生命周期中无障碍的操作这个 input 元素。 123&lt;div id=\"app\"&gt; &lt;date-picker date-format=\"yy-mm-dd\" v-once&gt;&lt;/date-picker&gt;&lt;/div&gt; 从 jQuery 向 Vue 传递数据如果我们不能在 app 中获取到 datepicker 选中的日期，那它就没啥用了。让我们来实现这个目标。 首先给 root 实例一个 date 属性： 123456new Vue(&#123; el: '#app', data: &#123; date: null &#125;&#125;); 1234&lt;div id=\"app\"&gt; &lt;date-picker date-format=\"yy-mm-dd\" v-once&gt;&lt;/date-picker&gt; &lt;p&gt;&#123;&#123; date &#125;&#125;&lt;/p&gt;&lt;/div&gt; datepicker 插件有一个 onSelect 回调函数来处理选中日期的操作。通过它我们可以在组件中使用自定义事件发出数据。 123456789mounted: function() &#123; var self = this; $(this.$el).datepicker(&#123; dateFormat: this.dateFormat, onSelect: function(date) &#123; self.$emit('update-date', date); &#125; &#125;);&#125; 在根实例上监听自定义事件并接收新数据： 1234&lt;div id=\"app\"&gt; &lt;date-picker @update-date=\"updateDate\" date-format=\"yy-mm-dd\" v-once&gt;&lt;/date-picker&gt; &lt;p&gt;&#123;&#123; date &#125;&#125;&lt;/p&gt;&lt;/div&gt; 1234567891011new Vue(&#123; el: '#app', data: &#123; date: null &#125;, methods: &#123; updateDate: function(date) &#123; this.date = date; &#125; &#125;&#125;); 感谢这个 Stack Overflow 回答 提供的灵感","link":"/2019/02/08/Use-jquery-in-vue/"}],"tags":[{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"Hardware accelerate","slug":"Hardware-accelerate","link":"/tags/Hardware-accelerate/"},{"name":"VueJS","slug":"VueJS","link":"/tags/VueJS/"},{"name":"jQuery","slug":"jQuery","link":"/tags/jQuery/"},{"name":"硬件加速","slug":"硬件加速","link":"/tags/硬件加速/"}],"categories":[]}